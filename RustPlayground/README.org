The installation of Rust also includes a copy of the documentation locally, so you can read it offline. Run ~rustup doc~ to open the local documentation in your browser.

In Rust, packages of code are referred to as crates

Building using Cargo: ~cargo build~

This command creates an executable file in target/debug/hello_cargo (or target\debug\hello_cargo.exe on Windows) rather than in your current directory. You can run the executable with this command:

$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!

We just built a project with cargo build and ran it with ./target/debug/hello_cargo, but we can also use ~cargo run~ to compile the code and then run the resulting executable all in one command.

Cargo also provides a command called ~cargo check~. This command quickly checks your code to make sure it compiles but doesn’t produce an executable. Often, cargo check is much faster than cargo build, because it skips the step of producing an executable. If you’re continually checking your work while writing the code, using cargo check will speed up the process! As such, many Rustaceans run cargo check periodically as they write their program to make sure it compiles. Then they run cargo build when they’re ready to use the executable.

When your project is finally ready for release, you can use ~cargo build --release~ to compile it with optimizations. This command
will create an executable in target/release instead of target/debug. The optimizations make your Rust code run faster, but turning them
on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you
want to rebuild quickly and often, and another for building the final program you’ll give to a user that won’t be rebuilt repeatedly and
that will run as fast as possible.

By default, Rust has a few items defined in the standard library that it brings into the scope of every program. This set is called the prelude, and you can see everything in it in the standard library documentation: https://doc.rust-lang.org/stable/std/prelude/index.html


In Rust, variables are immutable by default. We’ll be discussing this concept in detail in the “Variables and Mutability” section in Chapter 3. To make a variable mutable, we add mut before the variable name:
let apples = 5; // immutable
let mut bananas = 5; // mutable

The & indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust’s major advantages is how safe and easy it is to use references. Like variables, references are immutable by default.


