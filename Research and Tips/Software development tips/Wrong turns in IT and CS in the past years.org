What major wrong turns did information technology and computer science make over the past 30 years in your opinion?

Joshua Gross · November 11, 2019 Assistant Professor of Computer Science at CSUMB

Oh, wow, programming languages. Such bad. Such incredible bad.

Java, OK, definite win. Not fun, wordy, and it has its limits, but it was absolutely the right tool for the job. Easy to learn, hard to mess up, ideal for enterprise app dev and mobile apps, which account for probably 90% of professional code written today.

Python I don’t love, but I respect… except, can we agree on one version? Nah, let’s have two major versions simultaneously, and the “countless dev environments” approach of compiled languages in the late 80s/early 90s. Python is so simple to implement… so everyone has implemented it. YMMV, but OK, I’ll grant some good things about Python.

But PHP… “I’m sure this will scale!” I used to teach Cold Fusion, which was another clever, database-driven scripting languages. Could put sites up in minutes, as opposed to building an architecture… we still don’t have a good webdev platform IMO. You can cobble one together out of 6,000 components, but then you’re exposing your platform to risk… the exact problem that PHP has, on top of scalibility issues.

Javascript… I get what Eich was going for, but the language was never really good for programmers, and the implementations are awful. It is the textbook example of “explosion of platforms”. Smart companies chose their tools very carefully; I’ve seen unwise companies lose good devs at a rapid rate because somewhere, in their large app, every framework was used, and these people didn’t want to know 147 of them.

Haskell… I love FP, but Haskell and its community has increasingly moved to more abstract, complex mathematical models. “We’ll build around a math course that we all took and loved, and then everyone will abandon that flash-in-the-pan OO stupidity. Metaphor? What’s that? Who understands it? Everyone understands category theory, rings, and algebraic topology.” No. Bring back LISP. Or give Dylan the chance it never had. Or just accept that people understand metaphor and analogy much better than mathematics courses that they never took. As a basic language, Haskell is wonderful, but I wouldn’t use it for application development any sooner than Prolog.

Not that I’m opinionated or anything.

