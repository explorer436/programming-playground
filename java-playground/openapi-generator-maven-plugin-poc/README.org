* API first approach to API development

** Code First

In the code first approach, developers implement the application requirements directly. There is no contract or specification at first. It also requires a strong communication between the teams implementing application parts.

** The Value of API-First and the benefits of using API specifications for Organizations

An API‑first strategy is often ideal for microservices architectures because it ensures application ecosystems begin life as modular and reusable systems. Adopting an API‑first software development model provides significant benefits for both developers and organizations, including:

By developing with an API-First Design methodology, APIs are more than just a byproduct of an internal system. API-First Design establishes a contract for how your API communicates with other programs, even if the language behind a program is unknown.

1. Increased developer productivity – Development teams can work in parallel, able to update backend applications without impacting the teams working on other microservices which depend on the applications’ APIs. Collaboration is often easier across the API lifecycle since every team can refer to the established API contract.
1. Enhanced developer experience – API‑first design prioritizes the developer experience by ensuring that an API is logical and well‑documented. This creates a seamless experience for developers when they interact with an API. Learn why it’s so important for Platform Ops teams to take the API developer experience into consideration.
1. Consistent governance and security – Cloud and platform architects can organize the API ecosystem in a consistent way by incorporating security and governance rules during the API design phase. This avoids the costly reviews required when issues are discovered later in the software process.
1. Improved software quality – Designing APIs first ensures security and compliance requirements are met early in the development process, well before the API is ready to be deployed to production. With less need to fix security flaws in production, your operations, quality, and security engineering teams have more time to work directly with the development teams to ensure quality and security standards are met in the design phase.
1. Lower development cost - Using an API-First Methodology allows for the recycle of code between projects so development teams always have a baseline architecture to work with. This also reduces associated time and financial costs that are the result of starting from scratch. Developers can troubleshoot API issues sooner and often without any code, which leads to smoother integrations.
1. Adoption: The widest range of users/clients can adopt and consume your API.
1. Developer-friendly: Developers can easily use your API to integrate your app or service into their projects. The API specification enables good and consistent communication between teams.
1. Improved interoperability – A common, machine‑readable specification means different systems and clients can consume and use the API contract. This makes it easier for Platform Ops teams to integrate, manage, and monitor complex architectures.
1. Easy and Consistent documentation and API models – The API contract is documented in a standard format, including the endpoints, request and response formats, and other relevant details. Many systems can use the contract to generate comprehensive documentation, providing clarity and making it easier for developers to understand how to use the API.
1. Better testing – API specifications can be used to automatically generate and run tests, which can help ensure the API implementation adheres to the contract and is working as expected. This can help identify issues with an API before it is published to production.
1. Improved security – Advanced security tools can use the OpenAPI Specification to analyze API traffic and user behavior. They can apply positive security by verifying that API requests comply with the methods, endpoints, and parameters supported by the API endpoint. Non‑conforming traffic is blocked by default, reducing the number of calls your microservices have to process.
1. Easier evolution – API specifications can help facilitate the evolution of the API contract and application itself over time by providing a clear and standard way to document and communicate changes in both machine‑ and human‑readable formats. When coupled with proper versioning practices, this helps minimize the impacts of API changes on API consumers and ensures that an API remains backward compatible.
1. More Scalable Systems - The loose connections of APIs ensure that the services they expose are as Stateless And RESTful as possible. REST APIs allow for “loose” connections while minimizing or eliminating dependencies. This supports scalability because it’s easier to deploy, replicate, and destroy instances of a specific microservices app component in response to fluctuating demands on the system. 
1. Greater Flexibility to Upgrade and Update Systems - Well-designed APIs – and the fact that they promote app/client interactions without dependency – support pluggable, component-based architectures. This pluggability offers the flexibility to add, remove, or upgrade individual services/features while reducing the chance of impacting other parts of the system.
1. Highly-Available, Fault-Tolerant Systems - A microservices-based system that integrates through APIs allows you to build a highly-available and fault-tolerant system. This is because it’s easier to load-balance incoming requests, automate the deployment of microservices, achieve redundancy of key components, and carry out other orchestration strategies. Through the redundancy of systems and other fail-safes – like implementing Circuit Breaker Patterns – if one microservice fails, there is less chance of it negatively impacting the rest of the system.
1. Language and Platform Flexibility - APIs offer a language and platform agnostic interface that different microservices can interact with. Because API-first development prompts the creation of consistent and reusable APIs, the API-first approach helps your systems integrate with a wide range of services – regardless of their languages and platforms.  
1. Compatibility: Your app or service can integrate with a diverse array of apps and systems. 
1. Lowers Development Costs and Achieves Faster Time to Market - The pluggability that API-first achieves means that development teams can re-use different app components (or microservices) in other projects. Development teams can focus more time on building a minimum viable product, then complete the rest of the project by integrating with the APIs of other pre-built microservices components. With fewer dependencies and a consistent framework for interservice communication, different teams can build and improve their services much more efficiently. A consistent, machine‑readable API specification is one tool that can help developers and Platform Ops teams to work better together.   
1. Reusability
1. Separation of concerns
1. Development teams does not block each other

** References:   

1. https://www.nginx.com/blog/benefits-of-api-first-approach-to-building-microservices/
1. https://blog.dreamfactory.com/api-first-the-advantages-of-an-api-first-approach-to-app-development/#3
1. https://softjourn.com/insights/5-benefits-of-api-first-design

* Developer set-up instructions:

** Tools used:
    1. openjdk18
    1. mvn
    1. springboot
    1. openapi-generator-maven-plugin
    1. build-helper-maven-plugin
    1. springdoc-openapi

** Things to note:
    1. In the configuration for openapi-generator-maven-plugin in pom.xml, be sure to specify the package name correctly.
    1. Specifically, for the package with the Delegate interface.
    1. If it is different from the package name of the main class (with @SpringBootApplication), the application will not work properly. You may see 404 errors.

To install the package into the local repository, for use as a dependency in other projects locally: ~mvn clean install~

Plugin used to generate the artifacts from the OpenAPI specification file:
https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-maven-plugin

To generate sources from the specification file: ~mvn clean generate-sources~

To run the application: ~mvn spring-boot:run~

To view the OpenAPI specification in a browser when the application is running, paste this in a browser: ~http://localhost:8080/v3/api-docs/~

To test the application from terminal, use this command:
#+begin_src 
curl -X 'GET' \
  'http://localhost:8080/rewards/1' \
  -H 'accept: application/json'  
#+end_src

You can use this for testing if you use httpie: ~http GET http://localhost:8080/rewards/1~

Valid customerIds that would give you results: ~1,2,3,4~

*** Sample response from the application:

#+begin_src 
http GET http://localhost:8080/rewards/1
HTTP/1.1 200 
Connection: keep-alive
Content-Type: application/json
Date: Wed, 11 May 2022 18:55:48 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "customerId": "1",
    "rewards": [
        {
            "month": "APRIL",
            "purchaseAmount": 120.0,
            "rewardPoints": 90
        },
        {
            "month": "MARCH",
            "purchaseAmount": 130.0,
            "rewardPoints": 110
        },
        {
            "month": "FEBRUARY",
            "purchaseAmount": 140.0,
            "rewardPoints": 130
        }
    ],
    "totalPurchaseAmountForPastThreeMonths": 390.0,
    "totalRewardPointsForPastThreeMonths": 330
}
#+end_src

To invoke the grpc controller:
#+begin_src
curl -X 'GET' \
  'http://localhost:8080/grpc' \
  -H 'accept: application/json'
#+end_src

* Assignment description - Coding Guidelines for Java/Spring submissions

** Assignment and Instructions:
A retailer offers a rewards program to its customers, awarding points based on each recorded purchase.
 
A customer receives 2 points for every dollar spent over $100 in each transaction, plus 1 point for every dollar spent over $50 in each transaction
(e.g. a $120 purchase = 2x$20 + 1x$50 = 90 points).
 
Given a record of every transaction during a three month period, calculate the reward points earned for each customer per month and total.
 
1. Make up a data set to best demonstrate your solution
1. Check solution into GitHub and share the URL(Make it Public)
1. Solution should be built using ReactJS or Spring(Spring Boot)
1. Instructions for running the solution should be uploaded in ReadMe file on GitHub

** Mandatory
 
    1. Must expose  RESTful endpoint – for accepting a customer id and returning reward points [At a  minimum]  . Refer to the assignment for calculation logic of reward points 
    1. Do not use hard coded/magic  numbers in the code. 
    1. Ensure there is no unused variables in the project; that demonstrates the coding style. Try to close warnings from the project.
    1. Calculate awards points from the purchase amount. Don't exclude cents/decimal part while calculating.
    1. API responses should return appropriate payload and HTTP code for both Success and failed requests
    1. Create appropriate test data covering scenarios
    1. Include appropriate test cases
    1. Avoid pre-requisites like DB etc. Use In memory DB or other in memory option for data
    1. Readme file is mandatory – must contain the steps required to build and run/test the code
    1. The solution must be checked into Github (provide a public github url)
    1. Binary Files should not be checked into github
    1.  Calculate awards points from the purchase amount. Don't exclude cents/decimal part while calculating.

** The following are nice to have and demonstrates our knowledge of the framework
   
    1. We can also add an Exception Handler which serves as a catch all and send back INTERNAL_SERVER_ERROR in case of uncaught exceptions 
    1. In Spring, since the framework creates a proxy interface, we do not have to create an interface explicitly especially if there is only one implementation. 
    1. Try to use lombok for pojos, since the definition of a pojo comes across more precisely and it also provides useful annotations for the log4j bridge for logging
    1. Functional Programming constructs of Java 8 as appropriate.
    1. Please ensure to mention in Readme about build dependencies. Explicitly mention if its Maven or Gradle project.
 
