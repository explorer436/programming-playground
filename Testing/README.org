* Testing                                                               :TOC_4:
  - [[#springboot-testing][springboot testing]]
    - [[#testing-if-the-context-loads-correctly][Testing if the context loads correctly]]
    - [[#testing-if-the-context-creates-the-controller-or-any-other-beans-correctly][Testing if the context creates the controller (or any other beans) correctly]]
    - [[#dirtiescontext-annotation][DirtiesContext annotation]]
    - [[#testing-the-behavior-of-the-controller][Testing the behavior of the controller]]
      - [[#start-the-application-and-then-send-an-http-request-and-assert-the-response][Start the application and then send an HTTP request and assert the response]]
      - [[#do-not-start-the-server-at-all-and-use-springs-mockmvc-to-test-the-controller][Do not start the server at all and use Spring’s MockMvc to test the controller]]
      - [[#narrow-the-tests-to-only-the-web-layer-by-using-webmvctest][Narrow the tests to only the web layer by using @WebMvcTest]]
      - [[#webmvctest-with-mockbean][WebMvcTest with MockBean]]
  - [[#commands-to-run-tests-on-individual-files][Commands to run tests on individual files]]
    - [[#maven][Maven]]
      - [[#run-a-single-test-class-with-maven][Run a single test class with maven]]
      - [[#run-a-single-test-method-with-maven][Run a single test method with maven]]
    - [[#gradle][Gradle]]
    - [[#for-a-javascript-project][for a javascript project]]
  - [[#items-todo][Items TODO]]

** springboot testing

*** Testing if the context loads correctly

The @SpringBootTest annotation tells Spring Boot to look for a main configuration class (one with @SpringBootApplication, for instance) and use that to start a Spring application context.

Here is a simple sanity check test that will fail if the application context cannot start.
#+begin_src 
import org.junit.jupiter.api.Test;

import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class TestingWebApplicationTests {

	@Test
	public void contextLoads() {
	}

} 
#+end_src

*** Testing if the context creates the controller (or any other beans) correctly

If your app has a controller, to test if the context is creating your controller, you could add an assertion:

#+begin_src 
import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class SmokeTest {

	@Autowired
	private HomeController controller;

	@Test
	public void contextLoads() throws Exception {
		assertThat(controller).isNotNull();
	}
} 
#+end_src

Spring interprets the @Autowired annotation, and the controller is injected before the test methods are run. 

*** DirtiesContext annotation

A nice feature of the Spring Test support is that the application context is cached between tests. That way, if you have multiple methods in a test case or multiple test cases with the same configuration, they incur the cost of starting the application only once. You can control the cache by using the @DirtiesContext annotation.

*** Testing the behavior of the controller

**** Start the application and then send an HTTP request and assert the response

     Start the application and listen for a connection (as it would do in production) and then send an HTTP request and assert the response.
     webEnvironment=RANDOM_PORT starts the server with a random port (useful to avoid conflicts in test environments).
     The port is injected with @LocalServerPort.
     Spring Boot automatically provides a TestRestTemplate for you. All you have to do is add @Autowired to it.
     #+begin_src 
     import static org.assertj.core.api.Assertions.assertThat;

     import org.junit.jupiter.api.Test;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.boot.test.context.SpringBootTest;
     import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
     import org.springframework.boot.test.web.client.TestRestTemplate;
     import org.springframework.boot.test.web.server.LocalServerPort;
     
     @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
     public class HttpRequestTest {
     
     	@LocalServerPort
     	private int port;
     
     	@Autowired
     	private TestRestTemplate restTemplate;
     
     	@Test
     	public void greetingShouldReturnDefaultMessage() throws Exception {
     		assertThat(this.restTemplate.getForObject("http://localhost:" + port + "/",
     				String.class)).contains("Hello, World");
     	}
     }
     #+end_src

**** Do not start the server at all and use Spring’s MockMvc to test the controller

     Spring handles the incoming HTTP request and hands it off to your controller.
     With this approach, the code in the controller will be called in exactly the same way as if it were processing a real HTTP request but without the cost of starting the server. 
     Use Spring’s MockMvc and ask for that to be injected for you by using the @AutoConfigureMockMvc annotation on the test case.
     The full Spring application context is started but without the server. 
     #+begin_src 
     package com.example.weblayertestingforspringbootapp;

     import static org.hamcrest.Matchers.containsString;
     import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
     import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
     
     import org.junit.jupiter.api.Test;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
     import org.springframework.boot.test.context.SpringBootTest;
     import org.springframework.test.web.servlet.MockMvc;
     
     @SpringBootTest
     @AutoConfigureMockMvc
     public class TestingWebApplicationTest {
     
     	@Autowired
     	private MockMvc mockMvc;
     
     	@Test
     	public void shouldReturnDefaultMessage() throws Exception {
     		this.mockMvc.perform(get("/")).andDo(print()).andExpect(status().isOk())
     				.andExpect(content().string(containsString("Hello, World")));
     	}
     } 
     #+end_src

**** Narrow the tests to only the web layer by using @WebMvcTest     

     With this approach, Spring Boot instantiates only the web layer rather than the whole context.
     In an application with multiple controllers, you can even ask for only one to be instantiated by using, for example, @WebMvcTest(HomeController.class).

     #+begin_src 
     import static org.hamcrest.Matchers.containsString;
     import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
     import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
     
     import org.junit.jupiter.api.Test;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
     import org.springframework.test.web.servlet.MockMvc;
     
     @WebMvcTest
     public class WebLayerTest {
     
     	@Autowired
     	private MockMvc mockMvc;
     
     	@Test
     	public void shouldReturnDefaultMessage() throws Exception {
     		this.mockMvc.perform(get("/")).andDo(print()).andExpect(status().isOk())
     				.andExpect(content().string(containsString("Hello, World")));
     	}
     } 
     #+end_src

**** WebMvcTest with MockBean

     We use @MockBean to create and inject a mock for the GreetingService (if you do not do so, the application context cannot start), and we set its expectations using Mockito. 

     #+begin_src 
     import static org.hamcrest.Matchers.containsString;
     import static org.mockito.Mockito.when;
     import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
     import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
     import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
     
     import org.junit.jupiter.api.Test;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
     import org.springframework.boot.test.mock.mockito.MockBean;
     import org.springframework.test.web.servlet.MockMvc;
     
     import com.example.weblayertestingforspringbootapp.controller.GreetingController;
     import com.example.weblayertestingforspringbootapp.service.GreetingService;
     
     @WebMvcTest(GreetingController.class)
     public class WebMockTest {
     
     	@Autowired
     	private MockMvc mockMvc;
     
     	@MockBean
     	private GreetingService service;
     
     	@Test
     	public void greetingShouldReturnMessageFromService() throws Exception {
     		when(service.greet()).thenReturn("Hello, Mock");
     		this.mockMvc.perform(get("/greeting")).andDo(print()).andExpect(status().isOk())
     				.andExpect(content().string(containsString("Hello, Mock")));
     	}
     } 
     #+end_src


** Commands to run tests on individual files

*** Maven
   
**** Run a single test class with maven
    #+begin_src 
    mvn test -Dtest=classname
    #+end_src

**** Run a single test method with maven
    #+begin_src 
    mvn test -Dtest=classname#methodname
    #+end_src

*** Gradle
   
   #+begin_src 
    ./gradlew test --tests pagro.project.RunCukesTest*
   #+end_src

*** for a javascript project
   
   #+begin_src 
    npx jest ./src/main/module/Operation/OperationService.test.ts
    npm run test -- ./src/main/module/Operation/OperationService.test.ts
   #+end_src

   
** Items TODO

Junit testing using WireMock: https://wiremock.org/docs/junit-jupiter/

Serenity BDD: https://www.baeldung.com/serenity-bdd

Testing with Hamcrest: https://www.baeldung.com/java-junit-hamcrest-guide

A Guide to REST-assured: https://www.baeldung.com/rest-assured-tutorial

Integration Testing in Spring: https://www.baeldung.com/integration-testing-in-spring

Testing the web layer in a springboot application: https://spring.io/guides/gs/testing-web/

https://www.geeksforgeeks.org/types-software-testing/?ref=leftbar-rightbar
