* SQL topics                                                          :TOC_9:
- [[#database-model][Database model]]
- [[#dataflow-diagram-dfd][Dataflow diagram DFD]]
- [[#data-model][Data model]]
  - [[#data-modeling][Data modeling]]
- [[#sql][SQL]]
  - [[#named-sql-query][Named SQL query]]
  - [[#sqlexceptiontranslator][SQLExceptionTranslator]]
  - [[#sqlprovider][SQLProvider]]
  - [[#stored-procudures][Stored procudures]]
  - [[#sql-aggregate-functions][SQL Aggregate Functions]]
  - [[#sql-top][SQL TOP]]
  - [[#sql-like][SQL LIKE]]
  - [[#sql-wildcards][SQL Wildcards]]
  - [[#sql-in-operator][SQL IN Operator]]
  - [[#sql-between-operator][SQL BETWEEN Operator]]
  - [[#sql-alias][SQL Alias]]
  - [[#sql-joins][SQL Joins]]
  - [[#sql-join][SQL JOIN]]
    - [[#different-sql-joins][Different SQL JOINs]]
    - [[#sql-inner-join][SQL INNER JOIN]]
    - [[#sql-left-join--left-outer-join][SQL LEFT JOIN / LEFT OUTER JOIN]]
    - [[#sql-right-join--right-outer-join][SQL RIGHT JOIN / RIGHT OUTER JOIN]]
    - [[#sql-full-join][SQL FULL JOIN]]
    - [[#cartesian-or-cross-joins][CARTESIAN or CROSS JOINS]]
      - [[#cartesian-product][Cartesian product]]
  - [[#sql-union-and-unionall-operators][SQL UNION and UNIONALL Operators]]
    - [[#difference-between-union-and-unionall][Difference between UNION and UNIONALL]]
  - [[#sql-select-into-statement][SQL SELECT INTO Statement]]
  - [[#sql-create-database-statement][SQL CREATE DATABASE Statement]]
  - [[#sql-create-table-statement][SQL CREATE TABLE Statement]]
  - [[#sql-constraints][SQL Constraints]]
    - [[#sql-not-null-constraint][SQL NOT NULL Constraint]]
    - [[#sql-unique-constraint][SQL UNIQUE Constraint]]
    - [[#sql-primary-key-constraint][SQL PRIMARY KEY Constraint]]
    - [[#sql-foreign-key-constraint][SQL FOREIGN KEY Constraint]]
    - [[#sql-check-constraint][SQL CHECK Constraint]]
      - [[#sql-check-constraint-on-create-table][SQL CHECK Constraint on CREATE TABLE]]
    - [[#sql-default-constraint][SQL DEFAULT Constraint]]
      - [[#sql-default-constraint-on-create-table][SQL DEFAULT Constraint on CREATE TABLE]]
  - [[#sql-create-index-statement][SQL CREATE INDEX Statement]]
  - [[#indexes][Indexes]]
    - [[#sql-create-index-syntax][SQL CREATE INDEX Syntax]]
  - [[#the-drop-statement][The DROP Statement]]
  - [[#truncate-table-statement][TRUNCATE TABLE Statement]]
  - [[#sql-alter-table-statement][SQL ALTER TABLE Statement]]
  - [[#sql-auto-increment-field][SQL AUTO INCREMENT Field]]
  - [[#sql-views][SQL Views]]
    - [[#sql-create-view-statement][SQL CREATE VIEW Statement]]
    - [[#sql-create-view-examples][SQL CREATE VIEW Examples]]
    - [[#sql-updating-a-view][SQL Updating a View]]
  - [[#sql-date-functions][SQL Date Functions]]
    - [[#sql-dates][SQL Dates]]
    - [[#mysql-date-functions][MySQL Date Functions]]
    - [[#sql-server-date-functions][SQL Server Date Functions]]
  - [[#sql-null-values][SQL NULL Values]]
    - [[#sql-null-values-1][SQL NULL Values]]
    - [[#sql-null-functions][SQL NULL Functions]]
- [[#tables-vs-views][Tables vs Views]]
    - [[#table][Table]]
    - [[#view][View]]
- [[#cursors][Cursors]]
  - [[#implicit-cursors][Implicit cursors]]
  - [[#explicit-cursors][Explicit cursors]]
- [[#nolock][NOLOCK]]
- [[#what-is-database-normalization][What is Database Normalization?]]
  - [[#the-drawbacks-of-data-redundancy][The drawbacks of data redundancy]]
  - [[#types-of-database-normalization][Types of database normalization]]
  - [[#denormalization][Denormalization]]
  - [[#first-normal-form-1nf][First Normal Form (1NF)]]
  - [[#second-normal-form-2nf][Second Normal Form (2NF)]]
  - [[#third-normal-form-3nf][Third Normal Form (3NF)]]
  - [[#find-nth-highest-salary-from-a-table][Find Nth highest salary from a table]]
    - [[#using-limit-function][Using Limit function]]
    - [[#using-dense_rank][Using DENSE_RANK]]
    - [[#using-distinct-and-min-functions][Using DISTINCT and MIN functions]]

* Database model

A database model is the theoretical foundation of a database and fundamentally determines in which manner data can be
stored, organized, and manipulated in a database system. It thereby defines the infrastructure offered by a particular
database system. The most popular example of a database model is the relational model.

* Dataflow diagram DFD

DFD is a graphical representation of the flow of data through an information system, modeling its process aspects. it is a preliminary step used to create an overview of the system which can be later elaborated.

* Data model

A high-level data model in business or for any functional area is an abstract model that documents and organizes the business data for communication between functional and technical people. It is used to show the data needed and created by business processes.

** Data modeling

Data modeling in software engineering is the process of creating a data model for an information system by applying
formal data modeling techniques. Data modeling is a process used to define and analyze data requirements needed to
support the business processes within the scope of corresponding information systems in organizations. Therefore, the
process of data modeling involves professional data modelers working closely with business stakeholders, as well as
potential users of the information system.

* SQL
Structured Query Language. The standardized relational database language for defining database objects and
manipulating data.

** Named SQL query

** SQLExceptionTranslator

SQLExceptionTranslator, is an interface to be implemented by classes that can translate between SQLExceptions and Spring's own data-access-strategy-agnostic org.springframework.dao.DataAccessException.

** SQLProvider

1. Has one method – getSql()
1. Typically implemented byPreparedStatementCreator implementers.
1. Useful for debugging

** Stored procudures

1. A stored procedure is a subroutine available to applications that access a relational database system. A stored procedure (sometimes called a proc, sproc, StoPro, StoredProc, or SP) is actually stored in the database data dictionary.
1. Typical uses for stored procedures include data validation (integrated into the database) or access control mechanisms.
1. Furthermore, stored procedures can consolidate and centralize logic that was originally implemented in applications.
1. Extensive or complex processing that requires execution of several SQL statements is moved into stored procedures, and all applications call the procedures. One can use nested stored procedures, by executing one stored procedure from within another.
1. Stored procedures are great for processing complex SQL logic, securing and controlling access to data, and returning a rowset to a calling routine.
1. Stored procedures are similar to user-defined functions (UDFs). The major difference is that UDFs can be used like any other expression within SQL statements, whereas stored procedures must be invoked using the CALL statement.
1. A user defined function (UDF) is a prepared code segment that can accept parameters, process some logic, and then return some data. According to SQL Server Books Online, UDFs in SQL Server™ 2000 can accept anywhere from 0 to 1024 parameters, although I must confess I have never tried to pass 1024 parameters into a UDF. Another key characteristic of UDFs is that they return a value. Depending on the type of UDF, the value can be used by the calling routine to continue processing its data. Thus, if a UDF returns a single value (a scalar value), the calling routine can use that value anywhere a standard variable or a literal value can be used. If a UDF returns a rowset, the calling routine can loop through the rowset, join to it, or simply select columns from it.
1. Unlike views, stored procedures are compiled, making them ideal candidates to represent and process frequently run SQL statements.
1. Views are limited to only certain columns and rows from the underlying SELECT statement that generated the view. Thus a view is often used to represent a commonly used SELECT statement that may join several tables, employ a WHERE clause, and expose specific columns. Views are often found in the FROM clause of a SQL statement joined to other tables and views.
1. There are two main types of UDFs: scalar value-returning UDFs and table value-returning UDFs. Within table value UDFs you'll find UDFs that return inline tables and multistatement tables.

** SQL Aggregate Functions

An aggregate function is a function where the values of multiple rows are grouped together as input on certain criteria to form a single value of more significant meaning or measurement such as a set, a bag or a list.

Common aggregate functions include:
1. Average()
1. Count()
1. Maximum()
1. Median()
1. Minimum()
1. Mode()
1. Sum()

SQL aggregate functions return a single value, calculated from values in a column

** SQL TOP

1. The TOP clause is used to specify the number of records to return.
1. The TOP clause can be very useful on large tables with thousands of records.
1. Returning a large number of records can impact on performance.

   #+begin_src 
   SELECT TOP number|percent column_name(s)FROM table_name;
   SELECT TOP 2 * FROM Persons;
   SELECT TOP 50 PERCENT * FROM Persons;
   #+end_src

** SQL LIKE

The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
#+begin_src 
SELECT column_name(s)FROM table_name WHERE column_name LIKE pattern;
SELECT * FROM Persons WHERE City LIKE 's%';
#+end_src

** SQL Wildcards

1. SQL wildcards can substitute for one or more characters when searching for data in a database.
1. SQL wildcards must be used with the SQL LIKE operator.
1. With SQL, the following wildcards can be used: %, _, [charlist], [^charlist] or [!charlist]
   #+begin_src 
   SELECT * FROM Persons WHERE City LIKE '%nes%';
   SELECT * FROM Persons WHERE FirstName LIKE '_la';
   SELECT * FROM Persons WHERE LastName LIKE 'S_end_on';
   #+end_src

** SQL IN Operator

The IN operator allows you to specify multiple values in a WHERE clause.
#+begin_src 
SELECT column_name(s) FROM table_name WHERE
column_name IN (value1,value2,...);

SELECT * FROM Persons WHERE LastName IN ('Hansen','Pettersen');
#+end_src

** SQL BETWEEN Operator

1. The BETWEEN operator is used in a WHERE clause to select a range of data between two values.
1. The BETWEEN operator selects a range of data between two values. The values can be numbers, text, or dates.
   #+begin_src 
   SELECT column_name(s) FROM table_name WHERE
   column_name BETWEEN value1 AND value2;

   SELECT * FROM Persons WHERE
   LastName BETWEEN 'Hansen' AND 'Pettersen';
   #+end_src

** SQL Alias

With SQL, an alias name can be given to a table or to a column.
You can give a table or a column another name by using an alias. This can be a good thing to do if you have very long or complex table names or column names.
SQL Alias Syntax for Tables:

~SELECT column_name(s) FROM table_name AS alias_name;~

SQL Alias Syntax for Columns:
#+begin_src 
SELECT column_name AS alias_name FROM table_name;

SELECT po.OrderID, p.LastName, p.FirstName
FROM
Persons AS p, Product_Orders AS po
WHERE p.LastName='Hansen' AND p.FirstName='Ola';
#+end_src

** SQL Joins

SQL joins are used to query data from two or more tables, based on a relationship between certain columns in these tables.

** SQL JOIN

1. The JOIN keyword is used in an SQL statement to query data from two or more tables, based on a relationship between certain columns in these tables.
1. Tables in a database are often related to each other with keys.
1. A primary key is a column (or a combination of columns) with a unique value for each row. Each primary key value must be unique within the table. The purpose is to bind data together, across tables, without repeating all of the data in every table.

*** Different SQL JOINs

    Before we continue with examples, we will list the types of JOIN you can use, and the differences between them.
    1. JOIN: Return rows when there is at least one match in both tables
    1. LEFT JOIN: Return all rows from the left table, even if there are no matches in the right table
    1. RIGHT JOIN: Return all rows from the right table, even if there are no matches in the left table
    1. FULL JOIN: Return rows when there is a match in one of the tables

   [[./images/SQL_JOINS.png]]

*** SQL INNER JOIN

The INNER JOIN keyword return rows when there is at least one match in both tables.
#+begin_src 
SELECT column_name(s) FROM table_name1
INNER JOIN table_name2
ON table_name1.column_name=table_name2.column_name.
#+end_src

INNER JOIN is the same as JOIN.

#+begin_src 
SELECT
Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
INNER JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The INNER JOIN keyword return rows when there is at least one match in both tables. If there are rows in "Persons" that do not have matches in "Orders", those rows will NOT be listed.

*** SQL LEFT JOIN / LEFT OUTER JOIN

The LEFT JOIN keyword returns all rows from the left table (table_name1), even if there are no matches in the right table (table_name2).
#+begin_src 
SELECT column_name(s)
FROM table_name1
LEFT JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
LEFT JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The LEFT JOIN keyword returns all the rows from the left table (Persons), even if there are no matches in the right table (Orders).

*** SQL RIGHT JOIN / RIGHT OUTER JOIN

The RIGHT JOIN keyword returns all the rows from the right table (table_name2), even if there are no matches in the left table (table_name1).
#+begin_src 
SELECT column_name(s)
FROM table_name1
RIGHT JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
RIGHT JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The RIGHT JOIN keyword returns all the rows from the right table (Orders), even if there are no matches in the left table (Persons).

*** SQL FULL JOIN

The FULL JOIN keyword return rows when there is a match in one of the tables.
#+begin_src 
SELECT column_name(s)
FROM table_name1
FULL JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
FULL JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The FULL JOIN keyword returns all the rows from the left table (Persons), and all the rows from the right table (Orders). If there are rows in "Persons" that do not have matches in "Orders", or if there are rows in "Orders" that do not have matches in "Persons", those rows will be listed as well.

*** CARTESIAN or CROSS JOINS

The CARTESIAN JOIN or CROSS JOIN returns the Cartesian product of the sets of records from two or more joined tables.

**** Cartesian product

In mathematics, specifically set theory, the Cartesian product of two sets A and B, denoted A × B, is the set of all ordered pairs (a, b) where a is in A and b is in B.

[[./images/Cartesian_Product.png]]

e.g. If we have two tables - CUSTOMERS and ORDERS

#+begin_src 
 +----+----------+-----+-----------+----------+
| ID | NAME     | AGE | ADDRESS   | SALARY   |
+----+----------+-----+-----------+----------+
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |
|  2 | Khilan   |  25 | Delhi     |  1500.00 |
|  3 | kaushik  |  23 | Kota      |  2000.00 |
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |
|  6 | Komal    |  22 | MP        |  4500.00 |
|  7 | Muffy    |  24 | Indore    | 10000.00 |
+----+----------+-----+-----------+----------+ 

+-----+---------------------+-------------+--------+
|OID  | DATE                | CUSTOMER_ID | AMOUNT |
+-----+---------------------+-------------+--------+
| 102 | 2009-10-08 00:00:00 |           3 |   3000 |
| 100 | 2009-10-08 00:00:00 |           3 |   1500 |
| 101 | 2009-11-20 00:00:00 |           2 |   1560 |
| 103 | 2008-05-20 00:00:00 |           4 |   2060 |
+-----+---------------------+-------------+--------+
#+end_src

Now, let us join these two tables using CARTESIAN JOIN as follows −

#+begin_src 
SQL> SELECT  ID, NAME, AMOUNT, DATE
   FROM CUSTOMERS, ORDERS; 
#+end_src

 This would produce the following result −

#+begin_src 
+----+----------+--------+---------------------+
| ID | NAME     | AMOUNT | DATE                |
+----+----------+--------+---------------------+
|  1 | Ramesh   |   3000 | 2009-10-08 00:00:00 |
|  1 | Ramesh   |   1500 | 2009-10-08 00:00:00 |
|  1 | Ramesh   |   1560 | 2009-11-20 00:00:00 |
|  1 | Ramesh   |   2060 | 2008-05-20 00:00:00 |
|  2 | Khilan   |   3000 | 2009-10-08 00:00:00 |
|  2 | Khilan   |   1500 | 2009-10-08 00:00:00 |
|  2 | Khilan   |   1560 | 2009-11-20 00:00:00 |
|  2 | Khilan   |   2060 | 2008-05-20 00:00:00 |
|  3 | kaushik  |   3000 | 2009-10-08 00:00:00 |
|  3 | kaushik  |   1500 | 2009-10-08 00:00:00 |
|  3 | kaushik  |   1560 | 2009-11-20 00:00:00 |
|  3 | kaushik  |   2060 | 2008-05-20 00:00:00 |
|  4 | Chaitali |   3000 | 2009-10-08 00:00:00 |
|  4 | Chaitali |   1500 | 2009-10-08 00:00:00 |
|  4 | Chaitali |   1560 | 2009-11-20 00:00:00 |
|  4 | Chaitali |   2060 | 2008-05-20 00:00:00 |
|  5 | Hardik   |   3000 | 2009-10-08 00:00:00 |
|  5 | Hardik   |   1500 | 2009-10-08 00:00:00 |
|  5 | Hardik   |   1560 | 2009-11-20 00:00:00 |
|  5 | Hardik   |   2060 | 2008-05-20 00:00:00 |
|  6 | Komal    |   3000 | 2009-10-08 00:00:00 |
|  6 | Komal    |   1500 | 2009-10-08 00:00:00 |
|  6 | Komal    |   1560 | 2009-11-20 00:00:00 |
|  6 | Komal    |   2060 | 2008-05-20 00:00:00 |
|  7 | Muffy    |   3000 | 2009-10-08 00:00:00 |
|  7 | Muffy    |   1500 | 2009-10-08 00:00:00 |
|  7 | Muffy    |   1560 | 2009-11-20 00:00:00 |
|  7 | Muffy    |   2060 | 2008-05-20 00:00:00 |
+----+----------+--------+---------------------+
#+end_src


** SQL UNION and UNIONALL Operators

1. The SQL UNION operator combines/concatenates two or more SELECT statements.
1. The UNION operator is used to combine/concatenate the result-set of two or more SELECT statements.
1. Notice that each SELECT statement within the UNION must have the same number of columns. The columns must also have similar data types. Also, the columns in each SELECT statement must be in the same order.
#+begin_src 
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2;

SELECT column_name(s) FROM table_name1
UNION ALL
SELECT column_name(s) FROM table_name2;

SELECT E_Name FROM Employees_Norway
UNION
SELECT E_Name FROM Employees_USA;
#+end_src

*** Difference between UNION and UNIONALL

UNION: only keeps unique records
UNION ALL: keeps all records, including duplicates

** SQL SELECT INTO Statement

1. The SQL SELECT INTO statement can be used to create backup copies of tables.
1. The SELECT INTO statement selects data from one table and inserts it into a different table.
1. The SELECT INTO statement is most often used to create backup copies of tables.
1. We can select all columns into the new table:
   #+begin_src 
   SELECT *
   INTO new_table_name [IN externaldatabase]
   FROM old_tablename;
   #+end_src
1. Or we can select only the columns we want into the new table:
   #+begin_src 
   SELECT column_name(s)
   INTO new_table_name [IN externaldatabase]
   FROM old_tablename;
   SELECT * INTO Persons_Backup FROM Persons;
   #+end_src

** SQL CREATE DATABASE Statement

The CREATE DATABASE statement is used to create a database.
~CREATE DATABASE database_name~

** SQL CREATE TABLE Statement

The CREATE TABLE statement is used to create a table in a database.

** SQL Constraints

1. Constraints are used to limit the type of data that can go into a table.
1. Constraints can be specified when a table is created (with the CREATE TABLE statement) or after the table is created (with the ALTER TABLE statement).
1. We will focus on the following constraints:
   1. NOT NULL
   1. UNIQUE
   1. PRIMARY KEY
   1. FOREIGN KEY
   1. CHECK
   1. DEFAULT
   1. SQL NOT NULL Constraint
1. By default, a table column can hold NULL values.

*** SQL NOT NULL Constraint

1. The NOT NULL constraint enforces a column to NOT accept NULL values.
1. The NOT NULL constraint enforces a field to always contain a value. This means that you cannot insert a new record, or update a record without adding a value to this field.
1. The following SQL enforces the "P_Id" column and the "LastName" column to not accept NULL values:
   #+begin_src 
   CREATE TABLE Persons
   (
   P_Id int NOT NULL,
   LastName varchar(255) NOT NULL,
   FirstName varchar(255),
   Address varchar(255),
   City varchar(255)
   )
   #+end_src

*** SQL UNIQUE Constraint

1. The UNIQUE constraint uniquely identifies each record in a database table.
1. The UNIQUE and PRIMARY KEY constraints both provide a guarantee for uniqueness for a column or set of columns.
1. A PRIMARY KEY constraint automatically has a UNIQUE constraint defined on it.
1. Note that you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.

*** SQL PRIMARY KEY Constraint

1. The PRIMARY KEY constraint uniquely identifies each record in a database table.
1. Primary keys must contain unique values.
1. A primary key column cannot contain NULL values.
1. Each table should have a primary key, and each table can have only ONE primary key.

*** SQL FOREIGN KEY Constraint

A FOREIGN KEY in one table points to a PRIMARY KEY in another table.

*** SQL CHECK Constraint

1. The CHECK constraint is used to limit the value range that can be placed in a column.
1. If you define a CHECK constraint on a single column it allows only certain values for this column.
1. If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.

**** SQL CHECK Constraint on CREATE TABLE

     The following SQL creates a CHECK constraint on the "P_Id" column when the "Persons" table is created. The CHECK constraint specifies that the column "P_Id" must only include integers greater than 0.
     #+begin_src 
     CREATE TABLE Persons
     (
     P_Id int NOT NULL,
     LastName varchar(255) NOT NULL,
     FirstName varchar(255),
     Address varchar(255),
     City varchar(255),
     CHECK (P_Id>0)
     )
     #+end_src

*** SQL DEFAULT Constraint

1. The DEFAULT constraint is used to insert a default value into a column.
1. The default value will be added to all new records, if no other value is specified.

**** SQL DEFAULT Constraint on CREATE TABLE

     The following SQL creates a DEFAULT constraint on the "City" column when the "Persons" table is created:
     
     My SQL / SQL Server / Oracle / MS Access:
     
     #+begin_src 
     CREATE TABLE Persons
     (
     P_Id int NOT NULL,
     LastName varchar(255) NOT NULL,
     FirstName varchar(255),
     Address varchar(255),
     City varchar(255) DEFAULT 'Sandnes'
     )
     #+end_src

** SQL CREATE INDEX Statement

1. The CREATE INDEX statement is used to create indexes in tables.
1. Indexes allow the database application to find data fast; without reading the whole table.

** Indexes

An index can be created in a table to find data more quickly and efficiently.
The users cannot see the indexes, they are just used to speed up searches/queries.
Note: Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So you should only create indexes on columns (and tables) that will be frequently searched against.

*** SQL CREATE INDEX Syntax

Creates an index on a table. Duplicate values are allowed:

#+begin_src 
CREATE INDEX index_name ON table_name (column_name)

SQL DROP INDEX, DROP TABLE, and DROP DATABASE
#+end_src

Indexes, tables, and databases can easily be deleted/removed with the DROP statement.

** The DROP Statement

The DROP INDEX statement is used to delete an index in a table.

#+begin_src 
DROP TABLE table_name
#+end_src

** TRUNCATE TABLE Statement

1. What if we only want to delete the data inside the table, and not the table itself?
1. Then, use the TRUNCATE TABLE statement:

#+begin_src 
TRUNCATE TABLE table_name
#+end_src

** SQL ALTER TABLE Statement

The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.
#+begin_src 
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name ALTER COLUMN column_name datatype;
#+end_src

** SQL AUTO INCREMENT Field

1. Auto-increment allows a unique number to be generated when a new record is inserted into a table.
1. Very often we would like the value of the primary key field to be created automatically every time a new record is inserted.

** SQL Views

A view is a virtual table.
This chapter shows how to create, update, and delete a view.

*** SQL CREATE VIEW Statement

1. In SQL, a view is a virtual table based on the result-set of an SQL statement.
1. A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.
1. You can add SQL functions, WHERE, and JOIN statements to a view and present the data as if the data were coming from one single table.
   #+begin_src 
   CREATE VIEW view_name AS
   SELECT column_name(s)
   FROM table_name
   WHERE condition
   #+end_src
1. Note: A view always shows up-to-date data! The database engine recreates the data, using the view's SQL statement, every time a user queries a view.

*** SQL CREATE VIEW Examples

1. If you have the Northwind database you can see that it has several views installed by default.
1. The view "Current Product List" lists all active products (products that are not discontinued) from the "Products" table. The view is created with the following SQL:
   #+begin_src 
   CREATE VIEW [Current Product List] AS
   SELECT ProductID,ProductName FROM Products WHERE Discontinued=No;
   #+end_src

*** SQL Updating a View

You can update a view by using the following syntax:
#+begin_src 
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition;
#+end_src
Now we want to add the "Category" column to the "Current Product List" view. We will update the view with the following SQL:
#+begin_src 
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName,Category
FROM Products WHERE Discontinued=No;
#+end_src

** SQL Date Functions

*** SQL Dates

1. The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database.
1. As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets complicated.
1. Before talking about the complications of querying for dates, we will look at the most important built-in functions for working with dates.

*** MySQL Date Functions

The following table lists the most important built-in date functions in MySQL:

| Function      | Description                                              |
| NOW()         | Returns the current date and time                        |
| CURDATE()     | Returns the current date                                 |
| CURTIME()     | Returns the current time                                 |
| DATE()        | Extracts the date part of a date or date/time expression |
| EXTRACT()     | Returns a single part of a date/time                     |
| DATE_ADD()    | Adds a specified time interval to a date                 |
| DATE_SUB()    | Subtracts a specified time interval from a date          |
| DATEDIFF()    | Returns the number of days between two dates             |
| DATE_FORMAT() | Displays date/time data in different formats             |

*** SQL Server Date Functions

The following table lists the most important built-in date functions in SQL Server:
| GETDATE()  | Returns the current date and time                       |
| DATEPART() | Returns a single part of a date/time                    |
| DATEADD()  | Adds or subtracts a specified time interval from a date |
| DATEDIFF() | Returns the time between two dates                      |
| CONVERT()  | Displays date/time data in different formats            |

** SQL NULL Values

1. IS NULL and IS NOT NULL
1. NULL values represent missing unknown data.
1. By default, a table column can hold NULL values.

*** SQL NULL Values

1. If a column in a table is optional, we can insert a new record or update an existing record without adding a value to this column. This means that the field will be saved with a NULL value.
1. NULL values are treated differently from other values.
1. NULL is used as a placeholder for unknown or inapplicable values.

*** SQL NULL Functions

SQL ISNULL(), NVL(), IFNULL() and COALESCE() Functions

SQL Server / MS Access

#+begin_src 
SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))
FROM Products
#+end_src

Oracle: Oracle does not have an ISNULL() function. However, we can use the NVL() function to achieve the same result:

#+begin_src 
SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))
FROM Products
#+end_src

* Tables vs Views

*** Table

    Storage Unit Contain Rows and Columns. RDBMS is composed of tables that contain related data. table is stored in the database. Tables have physical existence.

*** View

    Logical Subset of Tables. View is an Database Object we can use DML it affects the base table and view. We can create a object for that table. View is a virtual table which do not have any physical existence.

1. This is one type of relation which is not a part of the physical database.
2. It has no direct or physical relation with the database.
3. Views can be used to provide security mechanism.
4. Modification through a view (e.g. insert, update, delete) generally not permitted

A VIEW is only a mirror image of table which is used at places where large access to a table is required.
Views cannot be updated,deleted and modified but we could select data from views easily.

Base Relation:

1. A base relation is a relation that is not a derived relation.
2. While it can manipulate the conceptual or physical relations stored in the data.
3. It does not provide security.
4. Modification may be done with a base relation.

We can assign the view, a name & relate it the query expression as “Create View as”

Let EMPLOYEE be the relation. We create the table EMPLOYEE as follows:-
#+begin_src 
Create table EMPLOYEE
(Emp_No integer of null,
Name char (20),
Skill chars (20),
Sal_Rate decimal (10, 2),
DOB date,
Address char (100),)
#+end_src

For a very personal or confidential matter, every user is not permitted to see the Sal_Rate of an EMPLOYEE. For such
users, DBA can create a view, for example, EMP_VIEW defined as:-
#+begin_src 
Create view EMP_VIEW as
(Select Emp_No, Name, Skill, DOB, Address
         From EMPLOYEE)
#+end_src

View :

1. Views are created from one or more than one table by joins, with selected columns.
2. Views acts as a layer between user and table.
3. Views are created to hide some columns from the user for security reasons, and to hide information exist in the column.
4. Views reduces the effort for writing queries to access specific columns every time.
5. Reports can be created on views.
6. View doesn't contain any data.

For data hiding to users from the data table we use views. Views stores only a particular query.Whenever we call that view it executes that query only. It does not store any data.We can also get some attributes of a table as view.
View is different perspective to see output from a table.
View data can not take part in Manipulation.
We can update or delete view.
View is nothing but a query file which stores the Sql Query, which is similar to the query file in Foxpro. When executed the query returns the rows from the tables specified in the query which satisfies the conditions (to a dynamic virtual table which has the column names specified in the query). That is why each and every time the view displays different result set depending on the data in the table.
View is a subset of data derived from table.
Update of data in table we can see in in view but update in view can not see in table.
Views are associated with tables.
We can create a view with base table and can able to execute DML(insert , delete,update and select ) statements if we update view then the base table get updated....

#+begin_src 
CREATE TABLE a( id int,name CHAR(20));
SELECT * FROM a;
INSERT INTO a VALUES(50,'e');
CREATE VIEW a1 AS SELECT * FROM a
SELECT * FROM a1;
INSERT INTO a1 VALUES(200,'ase');
DELETE FROM a1 WHERE id=100;
UPDATE a1
SET name='xyz'
WHERE id=10;
#+end_src

* Cursors

A cursor is a temporary work area created in the system memory when a SQL statement is executed. A cursor contains
information on a select statement and the rows of data accessed by it. This temporary work area is used to store the data
retrieved from the database, and manipulate this data. A cursor can hold more than one row, but can process only one
row at a time. The set of rows the cursor holds is called the active set.
There are two types of cursors in PL/SQL:

** Implicit cursors

These are created by default when DML statements like, INSERT, UPDATE, and DELETE statements are executed. They are also created when a SELECT statement that returns just one row is executed.

** Explicit cursors

They must be created when you are executing a SELECT statement that returns more than one row. Even though the cursor stores multiple records, only one record can be processed at a time, which is called as current row. When you fetch a row the current row position moves to next row.

Both implicit and explicit cursors have the same functionality, but they differ in the way they are accessed.

* NOLOCK

What is "with (nolock)" in SQL Server?

Explain the implications of using with (nolock) on queries. When should/shouldn't you use it?

For example, if you have a banking application with high transaction rates and a lot of data in certain tables, in what types of queries would nolock be okay? Are there cases when you should always use it/never use it?

WITH (NOLOCK) is the equivalent of using READ UNCOMMITED as a transaction isolation level. So, you stand the risk of reading an uncommitted row that is subsequently rolled back, i.e. data that never made it into the database. So, while it can prevent reads being deadlocked by other operations, it comes with a risk. In a banking application with high transaction rates, it's probably not going to be the right solution to whatever problem you're trying to solve with it IMHO.

With the NOLOCK hint (or setting the isolation level of the session to READ UNCOMMITTED) you tell SQL Server that you don't expect consistency, so there are no guarantees. Bear in mind though that "inconsistent data" does not only mean that you might see uncommitted changes that were later rolled back, or data changes in an intermediate state of the transaction. *It also means that in a simple query that scans all table/index data SQL Server may lose the scan position, or you might end up getting the same row twice.*

* What is Database Normalization?

https://en.wikipedia.org/wiki/Database_normalization

Database normalization is the process of restructuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity. It was first proposed by Edgar F. Codd as an integral part of his relational model.

Normalization entails organizing the columns (attributes) and tables (relations) of a database to ensure that their dependencies are properly enforced by database integrity constraints. It is accomplished by applying some formal rules either by a process of synthesis (creating a new database design) or decomposition (improving an existing database design).

** The drawbacks of data redundancy

1. Data maintenance becomes tedious – data deletion and data updates become problematic
1. It creates data inconsistencies
1. Insert, Update and Delete anomalies become frequent. An update anomaly, for example, means that the versions of the same record, duplicated in different places in the database, will all need to be updated to keep the record consistent
1. Redundant data inflates the size of a database and takes up an inordinate amount of space on disk

** Types of database normalization

The database normalization process is further categorized into the following types:

First Normal Form (1 NF)
Second Normal Form (2 NF)
Third Normal Form (3 NF)
Boyce Codd Normal Form or Fourth Normal Form ( BCNF or 4 NF)
Fifth Normal Form (5 NF)
Sixth Normal Form (6 NF)

** Denormalization

https://en.wikipedia.org/wiki/Denormalization

Denormalization is a strategy used on a previously-normalized database to increase performance. In computing, denormalization is the process of trying to improve the read performance of a database, at the expense of losing some write performance, by adding redundant copies of data or by grouping data. It is often motivated by performance or scalability in relational database software needing to carry out very large numbers of read operations. Denormalization should not be confused with Unnormalized form. Databases/tables must first be normalized to efficiently denormalize them.

** First Normal Form (1NF)

The first normal form requires that a table satisfies the following conditions:

1. Rows are not ordered
1. Columns are not ordered
1. There is duplicated data
1. Row-and-column intersections always have a unique value
1. All columns are “regular” with no hidden values

A table that violates 1NF. This contains more than one value in the Dept column.
#+begin_src 
EmpID     Employee   Age    Dept  
-----     --------   ---    ----
1001      ABC        30     Sales, Finance
1002      DEF        40     Sales, Finance, DevOps
#+end_src
   
Now, normalize this.

Department table
#+begin_src 
DeptID    DeptName
-----     ------------    ----  
1         Sales
2         Finance
3         DevOps
#+end_src

Employee table
#+begin_src 
EmpID     Employee   Age    DeptID
-----     --------   ---    ----  
1001      ABC        30     1
1001      ABC        30     2
1002      DEF        40     1
1002      DEF        40     2
1002      DEF        40     3
#+end_src

** Second Normal Form (2NF)

An entity is in a second normal form if all of its attributes depend on the whole primary key. So this means that the values in the different columns have a dependency on the other columns.

1. The table must be already in 1 NF and all non-key columns of the tables must depend on the PRIMARY KEY
1. The partial dependencies are removed and placed in a separate table

** Third Normal Form (3NF)

The third normal form states that you should eliminate fields in a table that do not depend on the key.

1. A Table is already in 2 NF
1. Non-Primary key columns shouldn’t depend on the other non-Primary key columns
1. There is no transitive functional dependency   

** Find Nth highest salary from a table   

Consider an Employee table
#+begin_src 
employeeName     Salary
------------     ------
A                23000
B                31000
C                24500
D                35000
E                28500
F                31500
G                39800
H                51000
I                39800
#+end_src

*** Using Limit function

#+begin_src 
select * from (
    (select * from Employee 
     ORDER BY `sal` DESC limit 6 ) AS T
) 
ORDER BY T.`sal` ASC limit 1;
#+end_src

or

#+begin_src 
select * from Employee
ORDER BY `sal` DESC limit 5,1;
// will return 6th highest
#+end_src

Limit clause has two components, First component is to skip  number of rows from top and second component is display number of rows we want. 

*** Using DENSE_RANK

#+begin_src 
select * from (
    select ename, sal, dense_rank() 
    over(order by sal desc)r from Employee
) 
where r=&n;
#+end_src

1. DENSE_RANK computes the rank of a row in an ordered group of rows and returns the rank as a NUMBER. The ranks are consecutive integers beginning with 1.
1. This function accepts arguments as any numeric data type and returns NUMBER.
1. As an analytic function, DENSE_RANK computes the rank of each row returned from a query with respect to the other rows, based on the values of the value_exprs in the order_by_clause.
1. In the above query the rank is returned based on sal of the employee table. In case of tie, it assigns equal rank to all the rows. 

To find to the 2nd highest sal set n = 2
To find 3rd highest sal set n = 3 and so on.

*** Using DISTINCT and MIN functions

1. Find the employees with top N distinct salaries.
1. Find the lowest salary among the salaries fetched by the above query, this will give us the Nth highest salary.
1. Find the details of the employee whose salary is the lowest salary fetched by the above query.

#+begin_src 
 SELECT * FROM Employee WHERE sal = 
         (
            SELECT MIN(sal) FROM Employee 
            WHERE  sal IN (
                                 SELECT DISTINCT TOP N
                                     sal FROM Employee 
                                         ORDER BY sal DESC
                             )
        ) 
#+end_src
