* SQL topics                                                          :TOC_9:
- [[#database-model][Database model]]
- [[#dataflow-diagram-dfd][Dataflow diagram DFD]]
- [[#data-model][Data model]]
  - [[#data-modeling][Data modeling]]
- [[#sql][SQL]]
  - [[#named-sql-query][Named SQL query]]
  - [[#sqlexceptiontranslator][SQLExceptionTranslator]]
  - [[#sqlprovider][SQLProvider]]
  - [[#stored-procudures-sql-related][Stored procudures (SQL related)]]
  - [[#sql-aggregate-functions--aggregate-functions][SQL Aggregate Functions / aggregate functions]]
  - [[#sql-top][SQL TOP]]
  - [[#sql-like][SQL LIKE]]
  - [[#sql-wildcards][SQL Wildcards]]
  - [[#sql-in-operator][SQL IN Operator]]
  - [[#sql-between-operator][SQL BETWEEN Operator]]
  - [[#sql-alias][SQL Alias]]
  - [[#sql-joins][SQL Joins]]
  - [[#sql-join][SQL JOIN]]
    - [[#different-sql-joins][Different SQL JOINs]]
    - [[#sql-inner-join][SQL INNER JOIN]]
    - [[#sql-left-join--left-outer-join][SQL LEFT JOIN / LEFT OUTER JOIN]]
    - [[#sql-right-join--right-outer-join][SQL RIGHT JOIN / RIGHT OUTER JOIN]]
    - [[#sql-full-join][SQL FULL JOIN]]
  - [[#sql-union-operator][SQL UNION Operator]]
  - [[#sql-select-into-statement][SQL SELECT INTO Statement]]
  - [[#sql-create-database-statement][SQL CREATE DATABASE Statement]]
  - [[#sql-create-table-statement][SQL CREATE TABLE Statement]]
  - [[#sql-constraints][SQL Constraints]]
    - [[#sql-not-null-constraint][SQL NOT NULL Constraint]]
    - [[#sql-unique-constraint][SQL UNIQUE Constraint]]
    - [[#sql-primary-key-constraint][SQL PRIMARY KEY Constraint]]
    - [[#sql-foreign-key-constraint][SQL FOREIGN KEY Constraint]]
    - [[#sql-check-constraint][SQL CHECK Constraint]]
      - [[#sql-check-constraint-on-create-table][SQL CHECK Constraint on CREATE TABLE]]
    - [[#sql-default-constraint][SQL DEFAULT Constraint]]
      - [[#sql-default-constraint-on-create-table][SQL DEFAULT Constraint on CREATE TABLE]]
  - [[#sql-create-index-statement][SQL CREATE INDEX Statement]]
  - [[#indexes][Indexes]]
    - [[#sql-create-index-syntax][SQL CREATE INDEX Syntax]]
  - [[#the-drop-statement][The DROP Statement]]
  - [[#truncate-table-statement][TRUNCATE TABLE Statement]]
  - [[#sql-alter-table-statement][SQL ALTER TABLE Statement]]
  - [[#sql-auto-increment-field][SQL AUTO INCREMENT Field]]
  - [[#sql-views][SQL Views]]
    - [[#sql-create-view-statement][SQL CREATE VIEW Statement]]
    - [[#sql-create-view-examples][SQL CREATE VIEW Examples]]
    - [[#sql-updating-a-view][SQL Updating a View]]
  - [[#sql-date-functions][SQL Date Functions]]
    - [[#sql-dates][SQL Dates]]
    - [[#mysql-date-functions][MySQL Date Functions]]
    - [[#sql-server-date-functions][SQL Server Date Functions]]
  - [[#sql-null-values][SQL NULL Values]]
    - [[#sql-null-values-1][SQL NULL Values]]
    - [[#sql-null-functions][SQL NULL Functions]]
- [[#tables-vs-views][Tables vs Views]]
    - [[#table][Table]]
    - [[#view][View]]
- [[#cursors][Cursors]]
  - [[#implicit-cursors][Implicit cursors]]
  - [[#explicit-cursors][Explicit cursors]]

* Database model

A database model is the theoretical foundation of a database and fundamentally determines in which manner data can be
stored, organized, and manipulated in a database system. It thereby defines the infrastructure offered by a particular
database system. The most popular example of a database model is the relational model.

* Dataflow diagram DFD

DFD is a graphical representation of the flow of data through an information system, modeling its process aspects. it is a preliminary step used to create an overview of the system which can be later elaborated.

* Data model

A high-level data model in business or for any functional area is an abstract model that documents and organizes the business data for communication between functional and technical people. It is used to show the data needed and created by business processes.

** Data modeling

Data modeling in software engineering is the process of creating a data model for an information system by applying
formal data modeling techniques. Data modeling is a process used to define and analyze data requirements needed to
support the business processes within the scope of corresponding information systems in organizations. Therefore, the
process of data modeling involves professional data modelers working closely with business stakeholders, as well as
potential users of the information system.

* SQL
Structured Query Language. The standardized relational database language for defining database objects and
manipulating data.

** Named SQL query

** SQLExceptionTranslator

SQLExceptionTranslator, is an interface to be implemented by classes that can translate between SQLExceptions and Spring's own data-access-strategy-agnostic org.springframework.dao.DataAccessException.

** SQLProvider

1. Has one method – getSql()
1. Typically implemented byPreparedStatementCreator implementers.
1. Useful for debugging

** Stored procudures (SQL related)

1. A stored procedure is a subroutine available to applications that access a relational database system. A stored procedure (sometimes called a proc, sproc, StoPro, StoredProc, or SP) is actually stored in the database data dictionary.
1. Typical uses for stored procedures include data validation (integrated into the database) or access control mechanisms.
1. Furthermore, stored procedures can consolidate and centralize logic that was originally implemented in applications.
1. Extensive or complex processing that requires execution of several SQL statements is moved into stored procedures, and all applications call the procedures. One can use nested stored procedures, by executing one stored procedure from within another.
1. Stored procedures are great for processing complex SQL logic, securing and controlling access to data, and returning a rowset to a calling routine.
1. Stored procedures are similar to user-defined functions (UDFs). The major difference is that UDFs can be used like any other expression within SQL statements, whereas stored procedures must be invoked using the CALL statement.
1. A user defined function (UDF) is a prepared code segment that can accept parameters, process some logic, and then return some data. According to SQL Server Books Online, UDFs in SQL Server™ 2000 can accept anywhere from 0 to 1024 parameters, although I must confess I have never tried to pass 1024 parameters into a UDF. Another key characteristic of UDFs is that they return a value. Depending on the type of UDF, the value can be used by the calling routine to continue processing its data. Thus, if a UDF returns a single value (a scalar value), the calling routine can use that value anywhere a standard variable or a literal value can be used. If a UDF returns a rowset, the calling routine can loop through the rowset, join to it, or simply select columns from it.
1. Unlike views, stored procedures are compiled, making them ideal candidates to represent and process frequently run SQL statements.
1. Views are limited to only certain columns and rows from the underlying SELECT statement that generated the view. Thus a view is often used to represent a commonly used SELECT statement that may join several tables, employ a WHERE clause, and expose specific columns. Views are often found in the FROM clause of a SQL statement joined to other tables and views.
1. There are two main types of UDFs: scalar value-returning UDFs and table value-returning UDFs. Within table value UDFs you'll find UDFs that return inline tables and multistatement tables.
refer: invoke stored procedures
refer: callable statement

** SQL Aggregate Functions / aggregate functions

An aggregate function is a function where the values of multiple rows are grouped together as input on certain criteria to form a single value of more significant meaning or measurement such as a set, a bag or a list.

Common aggregate functions include:
1. Average()
1. Count()
1. Maximum()
1. Median()
1. Minimum()
1. Mode()
1. Sum()

SQL aggregate functions return a single value, calculated from values in a column

** SQL TOP

1. The TOP clause is used to specify the number of records to return.
1. The TOP clause can be very useful on large tables with thousands of records.
1. Returning a large number of records can impact on performance.

   #+begin_src 
   SELECT TOP number|percent column_name(s)FROM table_name;
   SELECT TOP 2 * FROM Persons;
   SELECT TOP 50 PERCENT * FROM Persons;
   #+end_src

** SQL LIKE

The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
#+begin_src 
SELECT column_name(s)FROM table_name WHERE column_name LIKE pattern;
SELECT * FROM Persons WHERE City LIKE 's%';
#+end_src

** SQL Wildcards

1. SQL wildcards can substitute for one or more characters when searching for data in a database.
1. SQL wildcards must be used with the SQL LIKE operator.
1. With SQL, the following wildcards can be used: %, _, [charlist], [^charlist] or [!charlist]
   #+begin_src 
   SELECT * FROM Persons WHERE City LIKE '%nes%';
   SELECT * FROM Persons WHERE FirstName LIKE '_la';
   SELECT * FROM Persons WHERE LastName LIKE 'S_end_on';
   #+end_src

** SQL IN Operator

The IN operator allows you to specify multiple values in a WHERE clause.
#+begin_src 
SELECT column_name(s) FROM table_name WHERE
column_name IN (value1,value2,...);

SELECT * FROM Persons WHERE LastName IN ('Hansen','Pettersen');
#+end_src

** SQL BETWEEN Operator

1. The BETWEEN operator is used in a WHERE clause to select a range of data between two values.
1. The BETWEEN operator selects a range of data between two values. The values can be numbers, text, or dates.
   #+begin_src 
   SELECT column_name(s) FROM table_name WHERE
   column_name BETWEEN value1 AND value2;

   SELECT * FROM Persons WHERE
   LastName BETWEEN 'Hansen' AND 'Pettersen';
   #+end_src

** SQL Alias

With SQL, an alias name can be given to a table or to a column.
You can give a table or a column another name by using an alias. This can be a good thing to do if you have very long or complex table names or column names.
SQL Alias Syntax for Tables:

~SELECT column_name(s) FROM table_name AS alias_name;~

SQL Alias Syntax for Columns:
#+begin_src 
SELECT column_name AS alias_name FROM table_name;

SELECT po.OrderID, p.LastName, p.FirstName
FROM
Persons AS p, Product_Orders AS po
WHERE p.LastName='Hansen' AND p.FirstName='Ola';
#+end_src

** SQL Joins

SQL joins are used to query data from two or more tables, based on a relationship between certain columns in these tables.

** SQL JOIN

1. The JOIN keyword is used in an SQL statement to query data from two or more tables, based on a relationship between certain columns in these tables.
1. Tables in a database are often related to each other with keys.
1. A primary key is a column (or a combination of columns) with a unique value for each row. Each primary key value must be unique within the table. The purpose is to bind data together, across tables, without repeating all of the data in every table.

*** Different SQL JOINs

Before we continue with examples, we will list the types of JOIN you can use, and the differences between them.
1. JOIN: Return rows when there is at least one match in both tables
1. LEFT JOIN: Return all rows from the left table, even if there are no matches in the right table
1. RIGHT JOIN: Return all rows from the right table, even if there are no matches in the left table
1. FULL JOIN: Return rows when there is a match in one of the tables

*** SQL INNER JOIN

The INNER JOIN keyword return rows when there is at least one match in both tables.
#+begin_src 
SELECT column_name(s) FROM table_name1
INNER JOIN table_name2
ON table_name1.column_name=table_name2.column_name.
#+end_src

INNER JOIN is the same as JOIN.

#+begin_src 
SELECT
Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
INNER JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The INNER JOIN keyword return rows when there is at least one match in both tables. If there are rows in "Persons" that do not have matches in "Orders", those rows will NOT be listed.

*** SQL LEFT JOIN / LEFT OUTER JOIN

The LEFT JOIN keyword returns all rows from the left table (table_name1), even if there are no matches in the right table (table_name2).
#+begin_src 
SELECT column_name(s)
FROM table_name1
LEFT JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
LEFT JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The LEFT JOIN keyword returns all the rows from the left table (Persons), even if there are no matches in the right table (Orders).

*** SQL RIGHT JOIN / RIGHT OUTER JOIN

The RIGHT JOIN keyword returns all the rows from the right table (table_name2), even if there are no matches in the left table (table_name1).
#+begin_src 
SELECT column_name(s)
FROM table_name1
RIGHT JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
RIGHT JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The RIGHT JOIN keyword returns all the rows from the right table (Orders), even if there are no matches in the left table (Persons).

*** SQL FULL JOIN

The FULL JOIN keyword return rows when there is a match in one of the tables.
#+begin_src 
SELECT column_name(s)
FROM table_name1
FULL JOIN table_name2
ON table_name1.column_name=table_name2.column_name;

SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
FULL JOIN Orders
ON Persons.P_Id=Orders.P_Id
ORDER BY Persons.LastName;
#+end_src
The FULL JOIN keyword returns all the rows from the left table (Persons), and all the rows from the right table (Orders). If there are rows in "Persons" that do not have matches in "Orders", or if there are rows in "Orders" that do not have matches in "Persons", those rows will be listed as well.

** SQL UNION Operator

1. The SQL UNION operator combines two or more SELECT statements.
1. The UNION operator is used to combine the result-set of two or more SELECT statements.
1. Notice that each SELECT statement within the UNION must have the same number of columns. The columns must also have similar data types. Also, the columns in each SELECT statement must be in the same order.
#+begin_src 
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2;
SELECT column_name(s) FROM table_name1
UNION ALL
SELECT column_name(s) FROM table_name2;
SELECT E_Name FROM Employees_Norway
UNION
SELECT E_Name FROM Employees_USA;
#+end_src

** SQL SELECT INTO Statement

1. The SQL SELECT INTO statement can be used to create backup copies of tables.
1. The SELECT INTO statement selects data from one table and inserts it into a different table.
1. The SELECT INTO statement is most often used to create backup copies of tables.
1. We can select all columns into the new table:
   #+begin_src 
   SELECT *
   INTO new_table_name [IN externaldatabase]
   FROM old_tablename;
   #+end_src
1. Or we can select only the columns we want into the new table:
   #+begin_src 
   SELECT column_name(s)
   INTO new_table_name [IN externaldatabase]
   FROM old_tablename;
   SELECT * INTO Persons_Backup FROM Persons;
   #+end_src

** SQL CREATE DATABASE Statement

The CREATE DATABASE statement is used to create a database.
~CREATE DATABASE database_name~

** SQL CREATE TABLE Statement

The CREATE TABLE statement is used to create a table in a database.

** SQL Constraints

1. Constraints are used to limit the type of data that can go into a table.
1. Constraints can be specified when a table is created (with the CREATE TABLE statement) or after the table is created (with the ALTER TABLE statement).
1. We will focus on the following constraints:
   1. NOT NULL
   1. UNIQUE
   1. PRIMARY KEY
   1. FOREIGN KEY
   1. CHECK
   1. DEFAULT
   1. SQL NOT NULL Constraint
1. By default, a table column can hold NULL values.

*** SQL NOT NULL Constraint

1. The NOT NULL constraint enforces a column to NOT accept NULL values.
1. The NOT NULL constraint enforces a field to always contain a value. This means that you cannot insert a new record, or update a record without adding a value to this field.
1. The following SQL enforces the "P_Id" column and the "LastName" column to not accept NULL values:
   #+begin_src 
   CREATE TABLE Persons
   (
   P_Id int NOT NULL,
   LastName varchar(255) NOT NULL,
   FirstName varchar(255),
   Address varchar(255),
   City varchar(255)
   )
   #+end_src

*** SQL UNIQUE Constraint

1. The UNIQUE constraint uniquely identifies each record in a database table.
1. The UNIQUE and PRIMARY KEY constraints both provide a guarantee for uniqueness for a column or set of columns.
1. A PRIMARY KEY constraint automatically has a UNIQUE constraint defined on it.
1. Note that you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.

*** SQL PRIMARY KEY Constraint

1. The PRIMARY KEY constraint uniquely identifies each record in a database table.
1. Primary keys must contain unique values.
1. A primary key column cannot contain NULL values.
1. Each table should have a primary key, and each table can have only ONE primary key.

*** SQL FOREIGN KEY Constraint

A FOREIGN KEY in one table points to a PRIMARY KEY in another table.

*** SQL CHECK Constraint

1. The CHECK constraint is used to limit the value range that can be placed in a column.
1. If you define a CHECK constraint on a single column it allows only certain values for this column.
1. If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.

**** SQL CHECK Constraint on CREATE TABLE

     The following SQL creates a CHECK constraint on the "P_Id" column when the "Persons" table is created. The CHECK constraint specifies that the column "P_Id" must only include integers greater than 0.
     #+begin_src 
     CREATE TABLE Persons
     (
     P_Id int NOT NULL,
     LastName varchar(255) NOT NULL,
     FirstName varchar(255),
     Address varchar(255),
     City varchar(255),
     CHECK (P_Id>0)
     )
     #+end_src

*** SQL DEFAULT Constraint

1. The DEFAULT constraint is used to insert a default value into a column.
1. The default value will be added to all new records, if no other value is specified.

**** SQL DEFAULT Constraint on CREATE TABLE

     The following SQL creates a DEFAULT constraint on the "City" column when the "Persons" table is created:
     
     My SQL / SQL Server / Oracle / MS Access:
     
     #+begin_src 
     CREATE TABLE Persons
     (
     P_Id int NOT NULL,
     LastName varchar(255) NOT NULL,
     FirstName varchar(255),
     Address varchar(255),
     City varchar(255) DEFAULT 'Sandnes'
     )
     #+end_src

** SQL CREATE INDEX Statement

1. The CREATE INDEX statement is used to create indexes in tables.
1. Indexes allow the database application to find data fast; without reading the whole table.

** Indexes

An index can be created in a table to find data more quickly and efficiently.
The users cannot see the indexes, they are just used to speed up searches/queries.
Note: Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So you should only create indexes on columns (and tables) that will be frequently searched against.

*** SQL CREATE INDEX Syntax

Creates an index on a table. Duplicate values are allowed:

#+begin_src 
CREATE INDEX index_name ON table_name (column_name)

SQL DROP INDEX, DROP TABLE, and DROP DATABASE
#+end_src

Indexes, tables, and databases can easily be deleted/removed with the DROP statement.

** The DROP Statement

The DROP INDEX statement is used to delete an index in a table.

#+begin_src 
DROP TABLE table_name
#+end_src

** TRUNCATE TABLE Statement

1. What if we only want to delete the data inside the table, and not the table itself?
1. Then, use the TRUNCATE TABLE statement:

#+begin_src 
TRUNCATE TABLE table_name
#+end_src

** SQL ALTER TABLE Statement

The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.
#+begin_src 
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name ALTER COLUMN column_name datatype;
#+end_src

** SQL AUTO INCREMENT Field

1. Auto-increment allows a unique number to be generated when a new record is inserted into a table.
1. Very often we would like the value of the primary key field to be created automatically every time a new record is inserted.

** SQL Views

A view is a virtual table.
This chapter shows how to create, update, and delete a view.

*** SQL CREATE VIEW Statement

1. In SQL, a view is a virtual table based on the result-set of an SQL statement.
1. A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.
1. You can add SQL functions, WHERE, and JOIN statements to a view and present the data as if the data were coming from one single table.
   #+begin_src 
   SQL CREATE VIEW Syntax
   CREATE VIEW view_name AS
   SELECT column_name(s)
   FROM table_name
   WHERE condition
   #+end_src
1. Note: A view always shows up-to-date data! The database engine recreates the data, using the view's SQL statement, every time a user queries a view.

*** SQL CREATE VIEW Examples

1. If you have the Northwind database you can see that it has several views installed by default.
1. The view "Current Product List" lists all active products (products that are not discontinued) from the "Products" table. The view is created with the following SQL:
   #+begin_src 
   CREATE VIEW [Current Product List] AS
   SELECT ProductID,ProductName FROM Products WHERE Discontinued=No;
   #+end_src

*** SQL Updating a View

You can update a view by using the following syntax:
#+begin_src 
SQL CREATE OR REPLACE VIEW Syntax:
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition;
#+end_src
Now we want to add the "Category" column to the "Current Product List" view. We will update the view with the following SQL:
#+begin_src 
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName,Category
FROM Products WHERE Discontinued=No;
#+end_src

** SQL Date Functions

*** SQL Dates

1. The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database.
1. As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets complicated.
1. Before talking about the complications of querying for dates, we will look at the most important built-in functions for working with dates.

*** MySQL Date Functions

The following table lists the most important built-in date functions in MySQL:

| Function      | Description                                              |
| NOW()         | Returns the current date and time                        |
| CURDATE()     | Returns the current date                                 |
| CURTIME()     | Returns the current time                                 |
| DATE()        | Extracts the date part of a date or date/time expression |
| EXTRACT()     | Returns a single part of a date/time                     |
| DATE_ADD()    | Adds a specified time interval to a date                 |
| DATE_SUB()    | Subtracts a specified time interval from a date          |
| DATEDIFF()    | Returns the number of days between two dates             |
| DATE_FORMAT() | Displays date/time data in different formats             |

*** SQL Server Date Functions

The following table lists the most important built-in date functions in SQL Server:
| GETDATE()  | Returns the current date and time                       |
| DATEPART() | Returns a single part of a date/time                    |
| DATEADD()  | Adds or subtracts a specified time interval from a date |
| DATEDIFF() | Returns the time between two dates                      |
| CONVERT()  | Displays date/time data in different formats            |

** SQL NULL Values

1. IS NULL and IS NOT NULL
1. NULL values represent missing unknown data.
1. By default, a table column can hold NULL values.

*** SQL NULL Values

1. If a column in a table is optional, we can insert a new record or update an existing record without adding a value to this column. This means that the field will be saved with a NULL value.
1. NULL values are treated differently from other values.
1. NULL is used as a placeholder for unknown or inapplicable values.

*** SQL NULL Functions

SQL ISNULL(), NVL(), IFNULL() and COALESCE() Functions

SQL Server / MS Access

#+begin_src 
SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))
FROM Products
#+end_src

Oracle: Oracle does not have an ISNULL() function. However, we can use the NVL() function to achieve the same result:

#+begin_src 
SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))
FROM Products
#+end_src

* Tables vs Views

*** Table

    Storage Unit Contain Rows and Columns. RDBMS is composed of tables that contain related data. table is stored in the database. Tables have physical existence.

*** View

    Logical Subset of Tables. View is an Database Object we can use DML it affects the base table and view. We can create a object for that table. View is a virtual table which do not have any physical existence.

1. This is one type of relation which is not a part of the physical database.
2. It has no direct or physical relation with the database.
3. Views can be used to provide security mechanism.
4. Modification through a view (e.g. insert, update, delete) generally not permitted

A VIEW is only a mirror image of table which is used at places where large access to a table is required.
Views cannot be updated,deleted and modified but we could select data from views easily.

Base Relation:

1. A base relation is a relation that is not a derived relation.
2. While it can manipulate the conceptual or physical relations stored in the data.
3. It does not provide security.
4. Modification may be done with a base relation.

We can assign the view, a name & relate it the query expression as “Create View as”

Let EMPLOYEE be the relation. We create the table EMPLOYEE as follows:-
#+begin_src 
Create table EMPLOYEE
(Emp_No integer of null,
Name char (20),
Skill chars (20),
Sal_Rate decimal (10, 2),
DOB date,
Address char (100),)
#+end_src

For a very personal or confidential matter, every user is not permitted to see the Sal_Rate of an EMPLOYEE. For such
users, DBA can create a view, for example, EMP_VIEW defined as:-
#+begin_src 
Create view EMP_VIEW as
(Select Emp_No, Name, Skill, DOB, Address
         From EMPLOYEE)
#+end_src

View :

1. Views are created from one or more than one table by joins, with selected columns.
2. Views acts as a layer between user and table.
3. Views are created to hide some columns from the user for security reasons, and to hide information exist in the column.
4. Views reduces the effort for writing queries to access specific columns every time.
5. Reports can be created on views.
6. View doesn't contain any data.

For data hiding to users from the data table we use views. Views stores only a particular query.Whenever we call that view it executes that query only. It does not store any data.We can also get some attributes of a table as view.
View is different perspective to see output from a table.
View data can not take part in Manipulation.
We can update or delete view.
View is nothing but a query file which stores the Sql Query, which is similar to the query file in Foxpro. When executed the query returns the rows from the tables specified in the query which satisfies the conditions (to a dynamic virtual table which has the column names specified in the query). That is why each an every time the view displays different result set depending on the data in the table.
View is a subset of data derived from table.
Update of data in table we can see in in view but update in view can not see in table.
Views are associated with tables.
We can create a view with base table and can able to execute DML(insert , delete,update and select ) statements if we update view then the base table get updated....

#+begin_src 
CREATE TABLE a( id int,name CHAR(20));
SELECT * FROM a;
INSERT INTO a VALUES(50,'e');
CREATE VIEW a1 AS SELECT * FROM a
SELECT * FROM a1;
INSERT INTO a1 VALUES(200,'ase');
DELETE FROM a1 WHERE id=100;
UPDATE a1
SET name='xyz'
WHERE id=10;
#+end_src

* Cursors

A cursor is a temporary work area created in the system memory when a SQL statement is executed. A cursor contains
information on a select statement and the rows of data accessed by it. This temporary work area is used to store the data
retrieved from the database, and manipulate this data. A cursor can hold more than one row, but can process only one
row at a time. The set of rows the cursor holds is called the active set.
There are two types of cursors in PL/SQL:

** Implicit cursors

These are created by default when DML statements like, INSERT, UPDATE, and DELETE statements are executed. They are also created when a SELECT statement that returns just one row is executed.

** Explicit cursors

They must be created when you are executing a SELECT statement that returns more than one row. Even though the cursor stores multiple records, only one record can be processed at a time, which is called as current row. When you fetch a row the current row position moves to next row.

Both implicit and explicit cursors have the same functionality, but they differ in the way they are accessed.
