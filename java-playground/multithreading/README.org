
[[../multithreading/Callable and runnable.org]]

* What is the difference between runnable and callable in Java?

Multithreading is a major aspect of java language.

Both of these interfaces are implemented by the classes who wish to execute something (a piece of work) in a different thread of execution (than the thread that the class is running in). Runnable and Callable both run on a different thread than the calling thread. But Callable can return a value and Runnable cannot.

Runnable is the core interface provided for representing multithreaded tasks.

This interface is implemented by the Thread class as well and it's a common protocol for all the objects who wish to execute in a different thread. It's one of the ways of creating threads in Java. The other way to create a thread is by subclassing the Thread class. A class implementing Runnable interface can simply pass itself to create a Thread instance and can run thereafter. This eliminates the need of subclassing the Thread class for the purpose of executing the code in a separate thread.

As long as we don't wish to override other methods of the Thread class, it may be a better idea to implement the Runnable interface to enable multithreading capabilities to a class than enabling the same by extending the Thread class.

Callable was introduced in Java 1.5 to handle use-cases that ~Runnable~ does not support.

#+begin_src 
java.util.concurrent
Interface Callable<V>

Type Parameters:
V - the result type of method call  
#+end_src


In theory, the Java team could have changed the signature of the ~Runnable.run()~ method instead of introducing the ~Callable~ interface, but this would have broken binary compatiblity with pre-1.5 code.

~Runnable~ interface cannot do everything that ~Callable~ does.

There are use-cases where a task doesn't need to return a result or throw a checked exception. For those use-cases, using Runnable is more concise than using Callable<Void> and returning a dummy (null) value from the call() method.

1. Instances of the classes that implement Runnable or Callable interfaces are potentially executed by another thread.
1. Instance of both Callable and Runnable interfaces can be executed by ExecutorService via submit() method.
1. Both are functional interfaces and can be used in Lambda expressions since Java8.
1. Use Runnable for fire and forget calls. Use Callable to verify the result.

|----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------|
| Runnable                                                                   | Callable<T>                                                                                             |
|----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------|
| Introduced in Java 1.0 of java.lang                                        | Introduced in Java 1.5 of java.util.concurrent library                                                  |
| ~java.lang~ package                                                        | ~java.util.concurrent~ package                                                                          |
| Runnable tasks can be run using the Thread class or ExecutorService        | Callables can be run only using ExecutorService                                                         |
| Runnable has run() method                                                  | Callable has call() method                                                                              |
| Runnable.run() does not return anyting (returns void)                      | Callable.call() can return a value                                                                      |
| No way to propagate checked exceptions                                     | Callable's call()“throws Exception” clause so we can easily propagate checked exceptions further        |
| Runnable cannot be parametrized                                            | Callable is a parametrized type whose type parameter indicates the return type of its run method. call() method takes no arguments and returns a result of type V.    |
| ExecutorService.execute(Runnable) or ExecutorService.submit(Runnable task) | Executor.submit(Callable<T> task) or ExecutorService#invokeXXX(Collection<? extends Callable<T>> tasks) |

** Use cases

*** Runnable

    If you have a fire and forget task then use Runnable. Put your code inside a Runnable and when the run() method is called, you can perform your task. The calling thread really does not care when you perform your task.

*** Callable

    If you are trying to retrieve a value from a task, then use Callable. Now callable on its own will not do the job. You will need a Future that you wrap around your Callable and get your values on future.get (). Here the calling thread will be blocked till the Future comes back with results which in turn is waiting for Callable's call() method to execute.

So think about an interface to a target class where you have both Runnable and Callable wrapped methods defined. The calling class will randomly call your interface methods not knowing which is Runnable and which is Callable. The Runnable methods will execute asynchronously, till a Callable method is called. Here the calling class's thread will block since you are retrieving values from your target class.

NOTE : Inside your target class you can make the calls to Callable and Runnable on a single thread executor, making this mechanism similar to a serial dispatch queue. So as long as the caller calls your Runnable wrapped methods the calling thread will execute really fast without blocking. As soon as it calls a Callable wrapped in Future method it will have to block till all the other queued items are executed. Only then the method will return with values. This is a synchronization mechanism.

** Other differences

You can pass Runnable to create a Thread. But you can't create new Thread by passing Callable as parameter. You can pass Callable only to ExecutorService instances.



