* Threads                                                             :TOC_9:
- [[#thread][Thread]]
- [[#start-vs-run][start() vs run()]]
- [[#thread-vs-runnable][thread vs runnable]]
- [[#inter-thread-communication][inter thread communication]]
- [[#why-wait-notify-and-notifyall-is-declared-in-object-class-instead-of-thread][Why wait, notify and notifyAll is declared in Object Class instead of Thread?]]
- [[#how-to-write-thread-safe-code-in-java][How to write Thread-Safe Code in Java]]
- [[#how-to-kill-a-thread-in-java][How to kill a thread in Java?]]

* Thread

   The basic unit of program execution. A process can have several threads running concurrently, each performing a different job, such as waiting for events or performing a time-consuming job that the program doesn't need to complete before going on. When a thread has finished its job, the thread is suspended or destroyed.

   There are two ways of implementing threading in JAVA
   1. By extending java.lang.Thread class, or
   2. By implementing java.lang.Runnable interface.

* start() vs run()

Why do one call start method of thread if ~start()~ calls ~run()~ in turn? What is difference by calling ~start()~ over ~run()~ method in java thread?

Implement thread either overriding ~run()~ method of ~Thread~ class or implementing ~Runnable~ interface and than calling ~start()~ method on thread, but with some experience he finds that ~start()~ method calls ~run()~ method internally.

* thread vs runnable

   1. Java doesn't support multiple inheritance, which means you can only extend one class in Java so once you extended Thread class you lost your chance and can not extend or inherit another class in Java.
   1. In Object oriented programming extending a class generally means adding new functionality, modifying or improving behaviors. If we are not making any modification on Thread than use Runnable interface instead.
   1. Runnable interface represent a Task which can be executed by either plain Thread or Executors or any other means. so logical separation of Task as Runnable than Thread is good design decision.
   1. Separating task as Runnable means we can reuse the task and also has liberty to execute it from different means. since you can not restart a Thread once it completes. again Runnable vs Thread for task, Runnable is winner.
   1. Java designer recognizes this and that's why Executors accept Runnable as Task and they have worker thread which executes those task.
   1. Inheriting all Thread methods are additional overhead just for representing a Task which can can be done easily with Runnable.

   Implementing Runnable is better because in Java we can only extend one class so if we extend Thread class we can not extend any other class while by implementing Runnable interface we still have that option open with us. 

* inter thread communication

   Communication between the threads of the same process.
   
   Consider the classic queuing problem, where one thread is producing some data and another is consuming it. To make the problem more interesting, suppose that the producer has to wait until the consumer is finished before it generates more data.

   In a polling system, the consumer would waste many CPU cycles while it waited for the producer to produce. Once the producer was finished, it would start polling, wasting more CPU cycles waiting for the consumer to finish, and so on.

   Clearly, this situation is undesirable.

   To avoid polling, Java includes an elegant interprocess communication mechanism via the following methods:

   1. ~wait()~: This method tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls ~notify()~.
   1. ~notify()~: This method wakes up the first thread that called ~wait()~ on the same object.
   1. ~notifyAll()~: This method wakes up all the threads that called ~wait()~ on the same object. The highest priority thread will run first.

   These methods are implemented as final methods in Object, so all classes have them. All three methods can be called only from within a synchronized context.
   These methods are declared within Object. Various forms of ~wait()~ exist that allow you to specify a period of time to wait.

   All these methods must be called within a try-catch block.

* Why wait, notify and notifyAll is declared in Object Class instead of Thread?

1. Wait and notify are not just normal methods or synchronization utility. More than that, they are communication mechanism between two threads in Java. And Object class is the correct place to make them available for every object if this mechanism is not available via any java keyword like synchronized. Remember synchronized and wait notify are two different areas and donâ€™t confuse that they are same or related. Synchronized is to provide mutual exclusion and ensuring thread safety of Java class like race condition while wait and notify are communication mechanism between two thread.
1. Locks are made available on per Object basis, which is another reason wait and notify is declared in Object class rather then Thread class.
1. In Java in order to enter critical section of code, Threads needs lock and they wait for lock, they don't know which threads holds lock instead they just know the lock is hold by some thread and they should wait for lock instead of knowing which thread is inside the synchronized block and asking them to release lock. this analogy fits with wait and notify being on object class rather than thread in Java.

* How to write Thread-Safe Code in Java

   It refers to code which can safely be used or shared in concurrent or multi-threading environment and they will behave as expected. Any code, class or object which can behave differently from its contract on concurrent environment is not thread-safe.
   
   There are multiple ways to make this code thread safe in Java:
   
   1. Use ~synchronized~ keyword in Java and lock the getCount() method so that only one thread can execute it at a time which removes possibility of coinciding or interleaving.
   1. use Atomic Integer, which makes this ++ operation atomic and since atomic operations are thread-safe and saves cost of external synchronization.
   
   #+begin_src 
   public class Counter {
       private int count;
       AtomicInteger atomicCount = new AtomicInteger( 0 );
       /*
        * This method thread-safe now because of locking and synchornization
        */
       public synchronized int getCount(){
           return count++;
       }
       /*
        * This method is thread-safe because count is incremented atomically
        */
       public int getCountAtomically(){
           return atomicCount.incrementAndGet();
       }
   }
   #+end_src

   1. Immutable objects are by default thread-safe because there state can not be modified once created. Since String is immutable in Java, its inherently thread-safe.
   1. Read only or final variables in Java are also thread-safe in Java.
   1. Locking is one way of achieving thread-safety in Java.
   1. Static variables if not synchronized properly becomes major cause of thread-safety issues.
   1. Example of thread-safe class in Java: Vector, Hashtable, ConcurrentHashMap, String etc.
   1. Atomic operations in Java are thread-safe e.g. reading a 32 bit int from memory because its an atomic operation it can't interleave with other thread.
   1. local variables are also thread-safe because each thread has there own copy and using local variables is good way to writing thread-safe code in Java.
   1. In order to avoid thread-safety issue minimize sharing of objects between multiple thread.
   1. Volatile keyword in Java can also be used to instruct thread not to cache variables and read from main memory and can also instruct JVM not to reorder or optimize code from threading perspective.

* How to kill a thread in Java?

   TODO

   https://www.baeldung.com/java-thread-stop
