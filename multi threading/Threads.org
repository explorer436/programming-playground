* Threads                                                             :TOC_9:
- [[#multithreaded][Multithreaded]]
- [[#thread][Thread]]
- [[#start-vs-run][start() vs run()]]
- [[#thread-vs-runnable][thread vs runnable]]
- [[#inter-thread-communication][Inter thread communication]]
- [[#why-wait-notify-and-notifyall-is-declared-in-object-class-instead-of-thread][Why wait, notify and notifyAll is declared in Object Class instead of Thread?]]
- [[#how-to-write-thread-safe-code-in-java][How to write Thread-Safe Code in Java]]
- [[#how-to-kill-a-thread-in-java][How to kill a thread in Java?]]
- [[#synchronized-or-synchronization][synchronized (or synchronization)]]
  - [[#example-of-synchronized-block-in-java][Example of synchronized block in Java]]
  - [[#important-points-of-synchronized-keyword-in-java][Important points of synchronized keyword in Java]]
- [[#volatile][volatile]]
- [[#race-condition][Race condition]]
  - [[#how-to-find-race-conditions-in-java][How to find Race Conditions in Java]]
  - [[#code-example-of-race-condition-in-java][Code Example of Race Condition in Java]]
    - [[#check-and-act-race-condition-pattern]["Check and Act" race condition pattern]]
    - [[#read-modify-update-race-conditions][Read-modify-update race conditions]]
- [[#references][References]]

* Multithreaded

Describes a program that is designed to have parts of its code execute concurrently.

* Thread

   The basic unit of program execution. A process can have several threads running concurrently, each performing a different job, such as waiting for events or performing a time-consuming job that the program doesn't need to complete before going on. When a thread has finished its job, the thread is suspended or destroyed.

   There are two ways of implementing threading in JAVA
   1. By extending java.lang.Thread class, or
   2. By implementing java.lang.Runnable interface.

* start() vs run()

Why do one call start method of thread if ~start()~ calls ~run()~ in turn? What is difference by calling ~start()~ over ~run()~ method in java thread?

Implement thread either overriding ~run()~ method of ~Thread~ class or implementing ~Runnable~ interface and than calling ~start()~ method on thread, but with some experience he finds that ~start()~ method calls ~run()~ method internally.

* thread vs runnable

   1. Java doesn't support multiple inheritance, which means you can only extend one class in Java so once you extended Thread class you lost your chance and can not extend or inherit another class in Java.
   1. In Object oriented programming extending a class generally means adding new functionality, modifying or improving behaviors. If we are not making any modification on Thread than use Runnable interface instead.
   1. Runnable interface represent a Task which can be executed by either plain Thread or Executors or any other means. so logical separation of Task as Runnable than Thread is good design decision.
   1. Separating task as Runnable means we can reuse the task and also has liberty to execute it from different means. since you can not restart a Thread once it completes. again Runnable vs Thread for task, Runnable is winner.
   1. Java designer recognizes this and that's why Executors accept Runnable as Task and they have worker thread which executes those task.
   1. Inheriting all Thread methods are additional overhead just for representing a Task which can can be done easily with Runnable.

   Implementing Runnable is better because in Java we can only extend one class so if we extend Thread class we can not extend any other class while by implementing Runnable interface we still have that option open with us. 

* Inter thread communication

   Communication between the threads of the same process.
   
   Consider the classic queuing problem, where one thread is producing some data and another is consuming it. To make the problem more interesting, suppose that the producer has to wait until the consumer is finished before it generates more data.

   In a polling system, the consumer would waste many CPU cycles while it waited for the producer to produce. Once the producer was finished, it would start polling, wasting more CPU cycles waiting for the consumer to finish, and so on.

   Clearly, this situation is undesirable.

   To avoid polling, Java includes an elegant interprocess communication mechanism via the following methods:

   1. ~wait()~: This method tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls ~notify()~.
   1. ~notify()~: This method wakes up the first thread that called ~wait()~ on the same object.
   1. ~notifyAll()~: This method wakes up all the threads that called ~wait()~ on the same object. The highest priority thread will run first.

   These methods are implemented as final methods in Object, so all classes have them. All three methods can be called only from within a synchronized context.
   These methods are declared within Object. Various forms of ~wait()~ exist that allow you to specify a period of time to wait.

   All these methods must be called within a try-catch block.

* Why wait, notify and notifyAll is declared in Object Class instead of Thread?

1. Wait and notify are not just normal methods or synchronization utility. More than that, they are communication mechanism between two threads in Java. And Object class is the correct place to make them available for every object if this mechanism is not available via any java keyword like synchronized. Remember synchronized and wait notify are two different areas and don’t confuse that they are same or related. Synchronized is to provide mutual exclusion and ensuring thread safety of Java class like race condition while wait and notify are communication mechanism between two thread.
1. Locks are made available on per Object basis, which is another reason wait and notify is declared in Object class rather then Thread class.
1. In Java in order to enter critical section of code, Threads needs lock and they wait for lock, they don't know which threads holds lock instead they just know the lock is hold by some thread and they should wait for lock instead of knowing which thread is inside the synchronized block and asking them to release lock. this analogy fits with wait and notify being on object class rather than thread in Java.

* How to write Thread-Safe Code in Java

   It refers to code which can safely be used or shared in concurrent or multi-threading environment and they will behave as expected. Any code, class or object which can behave differently from its contract on concurrent environment is not thread-safe.
   
   There are multiple ways to make this code thread safe in Java:
   
   1. Use ~synchronized~ keyword in Java and lock the getCount() method so that only one thread can execute it at a time which removes possibility of coinciding or interleaving.
   1. use Atomic Integer, which makes this ++ operation atomic and since atomic operations are thread-safe and saves cost of external synchronization.
   
      #+begin_src 
      public class Counter {
          private int count;
          AtomicInteger atomicCount = new AtomicInteger( 0 );
          /*
           * This method thread-safe now because of locking and synchornization
           */
          public synchronized int getCount(){
              return count++;
          }
          /*
           * This method is thread-safe because count is incremented atomically
           */
          public int getCountAtomically(){
              return atomicCount.incrementAndGet();
          }
      }
      #+end_src
   1. Immutable objects are by default thread-safe because there state can not be modified once created. Since String is immutable in Java, its inherently thread-safe.
   1. Read only or final variables in Java are also thread-safe in Java.
   1. Locking is one way of achieving thread-safety in Java.
   1. Static variables if not synchronized properly becomes major cause of thread-safety issues.
   1. Example of thread-safe class in Java: Vector, Hashtable, ConcurrentHashMap, String etc.
   1. Atomic operations in Java are thread-safe e.g. reading a 32 bit int from memory because its an atomic operation it can't interleave with other thread.
   1. local variables are also thread-safe because each thread has there own copy and using local variables is good way to writing thread-safe code in Java.
   1. In order to avoid thread-safety issue minimize sharing of objects between multiple thread.
   1. Volatile keyword in Java can also be used to instruct thread not to cache variables and read from main memory and can also instruct JVM not to reorder or optimize code from threading perspective.

* How to kill a thread in Java?

   TODO

   https://www.baeldung.com/java-thread-stop

* synchronized (or synchronization)

A keyword in the Java programming language that, when applied to a method or code block, guarantees that at most one thread at a time executes that code.
Concurrent access of shared objects in Java introduces to kind of errors: thread interference and memory consistency errors.
Synchronization in Java will only be needed if shared object is mutable. If your shared object is read only or immutable object you don't need synchronization despite running multiple threads. Same is true with what threads are doing with object if all the threads are only reading value then you don't require synchronization in java. JVM guarantees that Java synchronized code will only be executed by one thread at a time.
1. synchronized keyword in java provides locking which ensures mutual exclusive access of shared resource and prevent data race.
2. synchronized keyword also prevent reordering of code statement by compiler which can cause subtle concurrent issue if we don't use synchronized or volatile keyword.
3. synchronized keyword involve locking and unlocking. before entering into synchronized method or block thread needs to acquire the lock at this point it reads data from main memory than cache and when it release the lock it flushes write operation into main memory which eliminates memory inconsistency errors.

You can have both static synchronized method and non static synchronized method and synchronized blocks in java but we can not have synchronized variable in java. Using synchronized keyword with variable is illegal and will result in compilation error. Instead of java synchronized variable you can have java volatile variable, which will instruct JVM threads to read value of volatile variable from main memory and don’t cache it locally. Block synchronization in java is preferred over method synchronization in java because by using block synchronization you only need to lock the critical section of code instead of whole method. Since java synchronization comes with cost of performance we need to synchronize only part of code which absolutely needs to be synchronized.

Using synchronized keyword along with method is easy just apply synchronized keyword in front of method. What we need to take care is that static synchronized method locked on class object lock and non static synchronized method locks on current object (this). So it’s possible that both static and non static java synchronized method running in parallel. This is the common mistake a naive developer do while writing java synchronized code.

#+begin_src 
public class Counter{

    private static int count = 0;

    public static synchronized int getCount(){
        return count;
    }

    public synchoronized setCount(int count){
        this.count = count;
    }
}
  
#+end_src

In this example of java synchronization code is not properly synchronized because both getCount() and setCount() are not getting locked on same object and can run in parallel which results in getting incorrect count. Here getCount() will lock in Counter.class object while setCount() will lock on current object (this). To make this code properly synchronized in java you need to either make both method static or non static or use java synchronized block instead of java synchronized method.

** Example of synchronized block in Java

Using synchronized block in java is also similar to using synchronized keyword in methods. Only important thing to note here is that if object used to lock synchronized block of code, Singleton.class in below example is null then java synchronized block will throw a NullPointerException.

#+begin_src 
public class Singleton{

    private static volatile Singleton _instance;

    public static Singleton getInstance(){
        if(_instance == null){
            synchronized(Singleton.class){
            if(_instance == null) {
                _instance = new Singleton();
            }
        }
    }

    return _instance;
}
  
#+end_src

This is a classic example of double checked locking in Singleton. In this example of java synchronized code we have made only critical section (part of code which is creating instance of singleton) synchronized and saved some performance because if you make whole method synchronized every call of this method will be blocked while you only need to create instance on first call.

** Important points of synchronized keyword in Java

1. Synchronized keyword in Java is used to provide mutual exclusive access of a shared resource with multiple threads in Java. Synchronization in java guarantees that no two threads can execute a synchronized method which requires same lock simultaneously or concurrently.
1. You can use java synchronized keyword only on synchronized method or synchronized block.
1. When ever a thread enters into java synchronized method or block it acquires a lock and whenever it leaves java synchronized method or block it releases the lock. Lock is released even if thread leaves synchronized method after completion or due to any Error or Exception.
1. Java Thread acquires an object level lock when it enters into an instance synchronized java method and acquires a class level lock when it enters into static synchronized java method.
1. java synchronized keyword is re-entrant in nature it means if a java synchronized method calls another synchronized method which requires same lock then current thread which is holding lock can enter into that method without acquiring lock.
1. Java Synchronization will throw NullPointerException if object used in java synchronized block is null e.g. synchronized (myInstance) will throws NullPointerException if myInstance is null.
1. One Major disadvantage of java synchronized keyword is that it doesn't allow concurrent read which you can implement using java.util.concurrent.locks.ReentrantLock.
1. One limitation of java synchronized keyword is that it can only be used to control access of shared object within the same JVM. If you have more than one JVM and need to synchronized access to a shared file system or database, the java synchronized keyword is not at all sufficient. You need to implement a kind of global lock for that.
1. Java synchronized keyword incurs performance cost. Synchronized method in Java is very slow and can degrade performance. So use synchronization in java when it absolutely requires and consider using java synchronized block for synchronizing critical section only.
1. Java synchronized block is better than java synchronized method in java because by using synchronized block you can only lock critical section of code and avoid locking whole method which can possibly degrade performance. A good example of java synchronization around this concept is getInstance() method Singleton class.
1. Its possible that both static synchronized and non static synchronized method can run simultaneously or concurrently because they lock on different object.
1. From java 5 after change in Java memory model reads and writes are atomic for all variables declared using volatile keyword (including long and double variables) and simple atomic variable access is more efficient instead of accessing these variables via synchronized java code. But it requires more care and attention from the programmer to avoid memory consistency errors.
1. Java synchronized code could result in deadlock or starvation while accessing by multiple thread if synchronization is not implemented correctly. To know how to avoid deadlock in java see here.
1. According to the Java language specification you can not use java synchronized keyword with constructor it’s illegal and result in compilation error. So you can not synchronized constructor in Java which seems logical because other threads cannot see the object being created until the thread creating it has finished it.
1. You cannot apply java synchronized keyword with variables and can not use java volatile keyword with method.
1. Java.util.concurrent.locks extends capability provided by java synchronized keyword for writing more sophisticated programs since they offer more capabilities e.g. Reentrancy and interruptible locks.
1. java synchronized keyword also synchronizes memory. In fact java synchronized synchronizes the whole of thread memory with main memory.
1. Important method related to synchronization in Java are wait(), notify() and notifyAll() which is defined in Object class.
1. Do not synchronize on non final field on synchronized block in Java. because reference of non final field may change any time and then different thread might synchronizing on different objects i.e. no synchronization at all. example of synchronizing on non final field :
   #+begin_src 
   private String lock = new String("lock");
   synchronized(lock){
       System.out.println("locking on :" + lock);
   }
   #+end_src
   If you try to write synchronized code like the above example in java, you may get the warning "Synchronization on non-final field".
1. Its not recommended to use String object as lock in java synchronized block because string is immutable object and literal string and interned string gets stored in String pool. so by any chance if any other part of code or any third party library used same String as there lock then they both will be locked on same object despite being completely unrelated which could result in unexpected behavior and bad performance. instead of String object its advised to use new Object() for Synchronization in Java on synchronized block.
   #+begin_src 
   private static final String LOCK = "lock"; //not recommended
   private static final Object OBJ_LOCK = new Object(); //better
   public void process() {
    synchronized(LOCK) {
    ........
    }
   }
   #+end_src
1. From Java library Calendar and SimpleDateFormat classes are not thread-safe and requires external synchronization in Java to be used in multi-threaded environment.

* volatile
A Java keyword used in variable declarations that specifies that the variable is modified asynchronously by concurrently running threads.

* Race condition

It is a type of concurrency bug or issue which is introduced in your program because parallel execution of your program
by multiple threads at same time.
Race conditions are just one of hazards or risk presented by use of multi-threading in Java just like deadlock in Java.
Race conditions occurs when two thread operate on same object without proper synchronization and there operation
interleaves on each other. Classical example of Race condition is incrementing a counter since increment is not an
atomic operation and can be further divided into three steps like read, update and write. If two threads tries to increment
count at same time and if they read same value because of interleaving of read operation of one thread to update
operation of another thread, one count will be lost when one thread overwrite increment done by other thread. atomic
operations are not subject to race conditions because those operation cannot be interleaved.

** How to find Race Conditions in Java

finding race conditions by unit testing is not reliable due to random nature of race conditions. since race conditions
surfaces only some time your unit test may passed without facing any race condition. only sure shot way to find race
condition is reviewing code manually or using code review tools which can alert you on potential race conditions based on
code pattern and use of synchronization in Java. most people solely rely on code review strategy and yet to find a suitable
tool for exposing race condition in java.

** Code Example of Race Condition in Java

Two code patterns namely "check and act" and "read modify write" can suffer race condition if not synchronized properly. both cases rely on natural assumption that a single line of code will be atomic and execute in one shot which is wrong e.g. ++ is not atomic.

*** "Check and Act" race condition pattern

classical example of "check and act" race condition in Java is getInstance() method of Singleton Class.
getInstace() method first check for whether instance is null and than initialized the instance and return to caller. Whole
purpose of Singleton is that getInstance should always return same instance of Singleton. if you call getInstance()
method from two thread simultaneously its possible that while one thread is initializing singleton after null check, another
thread sees value of _instance reference variable as null (quite possible in java) especially if your object takes longer time
to initialize and enters into critical section which eventually results in getInstance() returning two separate instance of
Singleton. This may not happen always because a fraction of delay may result in value of _instance updated in main
memory. here is a code example
#+begin_src 
public Singleton getInstance(){
    if(_instance == null){
        //race condition if two threads sees _instance= null
        _instance = new Singleton();
    }
}
#+end_src

An easy way to fix "check and act" race conditions is to synchronized keyword and enforce locking which will make this operation atomic and guarantees that block or method will only be executed by one thread and result of operation will be visible to all threads once synchronized blocks completed or thread exited form synchronized block.

*** Read-modify-update race conditions

This is another code pattern in Java which cause race condition, classical example is the non thread safe counter.
read-modify-update pattern also comes due to improper synchronization of non-atomic operations or combination of two
individual atomic operations which is not atomic together e.g. put if absent scenario. Consider below code

#+begin_src 
if(!hashtable.contains(key)){
    hashtable.put(key,value);
}
#+end_src

Here we only insert object into hashtable if its not already there. point is both contains() and put() are atomic but still this
code can result in race condition since both operation together is not atomic. consider thread T1 checks for conditions and
goes inside if block now CPU is switched from T1 to thread T2 which also checks condition and goes inside if block. now
we have two thread inside if block which result in either T1 overwriting T2 value or vice-versa based on which thread has
CPU for execution. In order to fix this race condition in Java you need to wrap this code inside synchronized block
which makes them atomic together because no thread can go inside synchronized block if one thread is already there

* References

   See "Producer Consumer Design Pattern"
