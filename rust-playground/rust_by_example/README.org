* Project structure

How can we have multiple ~main()~ in same crate?

I'm trying to code some very simple utilities to help me manipulating source code from command line. (e.g. extracting headers from Java or Python sources)

Most of these programs just pick a file from command line args, and after some checking, load its contents, calls a function and outputs the result.

I can create a crate for each small program, of course, but I wonder if it is possible to define more than one main() in the same crate.

So the question is: is it possible (and how) to define more than one main() in the same crate?

Answer:

Use this project structure for working through coding challenges:

#+begin_src
/src/bin/problem-101.rs
/src/bin/problem-143.rs
/src/lib.rs
/Cargo.toml
#+end_src

Essentially, create a bin/ folder in src/, create separate source files for each problem in there, and off you go!

1. Instead of ~src/main.rs~ you can have ~src/bin/tool1.rs~ and ~src/bin/tool2.rs~ etc.
1. If you then have ~src/lib.rs~, then all those can access a single support crate for code, making things compile faster.
1. structops is an alternative.

This structure is easy to use and extend with small "scripts" because Rust source files in the /src/bin folder are automatically detected as binaries and do not need to be listed separately in Cargo.toml. You can run them directly:

#+begin_src
> cargo run --bin problem-101
   Compiling challenges v0.1.0 (...\challenges)
    Finished dev [unoptimized + debuginfo] target(s) in 0.26s
     Running `target\debug\problem-101.exe`
solution #101
> cargo run --bin problem-143
   Compiling challenges v0.1.0 (...\challenges)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target\debug\problem-143.exe`
solution #143
#+end_src

Using a library as the root of the project allows you to share functions and logic between your problems very easily. Just import from the library like so:

#+begin_src
use challenges::add;
#+end_src

Reference: https://stackoverflow.com/questions/73738228/how-should-i-structure-a-rust-project-for-solving-small-coding-challenges

* Running cargo commands

https://doc.rust-lang.org/cargo/commands/index.html
https://doc.rust-lang.org/cargo/commands/build-commands.html

#+begin_src
cargo test
cargo build
#+end_src

* Folder structure

TODO
Create crates for these:

variables_mutation_shadowing
matrix
traits

#+begin_src
01_getting_started_and_basics
    │       ├── 01_guessing_game.rs
    │       ├── 02_hello_world_without_cargo.rs
    │       └── 03_hello_world_using_cargo.rs
02_formatting_debugging_displaying_printing
    │       ├── 01_formatted_print.rs
    │       ├── 02_formatted_print_debugging.rs
    │       ├── 03_formatted_print_displaying.rs
    │       └── 04_formatted_print_formatting.rs
03_primitives_literals_operators
    │       ├── 01_primitives.rs
    │       ├── 02_primitives_literals_and_operators.rs
    │       ├── 03_primitives_tuples.rs
    │       └── 04_primitives_arrays_and_slices.rs
04_expressions
    │       └── 01_expressions.rs
05_constants_and_simple_types
    │       ├── 01_constants.rs
    │       ├── 02_type_literals.rs
    │       └── 03_simple_types.rs
06_custom_types
    │       ├── 01_custom_types_structs.rs
    │       ├── 02_custom_types_structs_traits.rs
    │       ├── 03_custom_types_enums.rs
    │       ├── 04_custom_types_use_keyword.rs
    │       ├── 05_custom_types_linked_list_via_enums.rs
    │       └── 06_custom_types_constants_and_static_variables.rs
07_type_casting_type_inference_type_aliasing
    │       ├── 01_type_casting.rs
    │       ├── 02_type_inference.rs
    │       └── 03_type_aliasing.rs
08_conversions_from_one_type_to_another
    │       ├── 01_conversion_from_and_into.rs
    │       ├── 02_conversion_try_from_and_try_into.rs
    │       └── 03_conversion_to_and_from_strings.rs
09_macros
    │       ├── 01_macro_rules.rs
    │       ├── 02_macro-rules_syntax-designators.rs
    │       ├── 03_macro-rules_syntax-overload.rs
    │       ├── 04_macro-rules_syntax-repeat.rs
    │       ├── 05_macro-rules_dry-do-not-repeat-yourself.rs
    │       ├── 06_macro-rules_dsl-domain-specific-languages.rs
    │       └── 07_macro-rules_variadics.rs
10_flow_of_controls
    │       ├── 01_flow_of_control_if-else.rs
    │       ├── 02_flow_of_control_loop.rs
    │       ├── 03_flow_of_control_loop-nesting-and-labels.rs
    │       ├── 04_flow_of_control_loop-returning-from-loops.rs
    │       ├── 05_flow_of_control_while.rs
    │       ├── 06_flow_of_control_for-and-range.rs
    │       ├── 07_flow_of_control_match.rs
    │       ├── 08_flow_of_control_match-destructuring-tuples.rs
    │       ├── 09_flow_of_control_match-destructuring-arrays-slices.rs
    │       ├── 10_flow_of_control_match-destructuring-enums.rs
    │       ├── 11_flow_of_control_match-destructuring-pointers-ref.rs
    │       ├── 12_flow_of_control_match-destructuring-structs.rs
    │       ├── 13_flow_of_control_match-guards.rs
    │       ├── 14_flow_of_control_match-binding.rs
    │       ├── 15_flow_of_control_if-let.rs
    │       └── 16_flow_of_control_while-let.rs
11_functions
    │       ├── 01_functions.rs
    │       ├── 02_functions_methods.rs
    │       ├── 03_functions_closures.rs
    │       ├── 04_functions_capturing.rs
    │       ├── 05_functions_as-input-parameters.rs
    │       ├── 06_functions_type-anonymity.rs
    │       ├── 07_functions_input-functions.rs
    │       ├── 08_functions_as-output-parameters.rs
    │       ├── 09_Iterators.rs
    │       ├── 10_functions_iter.rs
    │       ├── 11_functions_into-iter.rs
    │       ├── 12_functions_searching-through-iterators.rs
    │       ├── 13_functions_higher-order-functions.rs
    │       └── 14_functions_diverging-functions.rs
12_modules
    │       ├── 01_modules_visibility.rs
    │       ├── 02_modules_struct-visibility.rs
    │       ├── 03_modules_the-use-declaration.rs
    │       └── 04_modules_super-and-self.rs
13_generics
    │       ├── 01_generics.rs
    │       ├── 02_generics_functions.rs
    │       ├── 03_generics_implementation.rs
    │       ├── 04_generics_traits.rs
    │       ├── 05_generics_bounds.rs
    │       ├── 06_generics_testcase-empty-bounds.rs
    │       ├── 07_generics_multiple-bounds.rs
    │       ├── 08_generics_where-clauses.rs
    │       ├── 09_generics_new-type-idiom.rs
    │       ├── 10_generics_associated-items-the-problem.rs
    │       ├── 11_generics_associated-items-associated-types.rs
    │       ├── 12_generics_phantom-type-parameters.rs
    │       └── 13_generics_testcase-unit-clarification.rs
14_scoping_rules
    │       ├── 01_scoping_rules-raii.rs
    │       ├── 02_scoping_rules-ownership-and-moves.rs
    │       ├── 03_scoping_rules-ownership-and-moves-mutability.rs
    │       ├── 04_scoping_rules-ownership-and-moves-partial-moves.rs
    │       ├── 05_scoping_rules-borrowing.rs
    │       ├── 06_scoping_rules-borrowing-mutability.rs
    │       ├── 07_scoping_rules-borrowing-aliasing.rs
    │       ├── 08_scoping_rules-borrowing-the-ref-pattern.rs
    │       ├── 09_scoping_rules-lifetimes.rs
    │       ├── 10_scoping_rules-lifetimes-explicit-annotation.rs
    │       ├── 11_scoping_rules-lifetimes-functions.rs
    │       ├── 12_scoping_rules-lifetimes-methods.rs
    │       ├── 13_scoping_rules-lifetimes-structs.rs
    │       ├── 14_scoping_rules-lifetimes-traits.rs
    │       ├── 15_scoping_rules-lifetimes-bounds.rs
    │       ├── 16_scoping_rules-lifetimes-coercion.rs
    │       ├── 17_scoping_rules-lifetimes-static.rs
    │       └── 18_scoping_rules-lifetimes-elision.rs
15_traits
    │       ├── 01_traits.rs
    │       ├── 02_traits_derive.rs
    │       ├── 03_traits_returning-traits-with-dyn.rs
    │       ├── 04_traits_operator-overloading.rs
    │       ├── 05_traits_drop.rs
    │       ├── 06_traits_fibonacci_sequence_using_iterator_trait.rs
    │       ├── 07_traits_fibonacci_sequence_without_using_iterator_trait.rs
    │       ├── 08_traits_even_fibonacci_sequence_using_iterator_trait.rs
    │       ├── 09_traits.rs
    │       ├── 10_traits.rs
    │       ├── 11_traits.rs
    │       └── 12_traits_disambiguating_overlapping_traits.rs
bin
├── main.rs
├── matrix.rs
├── regenerate_hugo_md_files.rs
└── variables_mutability_shadowing.rs
lib.rs
numbers
├── generate_a_list_of_all_even_numbers_till_n.rs
├── generate_a_list_of_first_n_even_numbers.rs
└── mod.rs
rectangle
├── mod.rs
└── rectangle.rs
strings
├── fizz_buzz.rs
└── mod.rs
trees
├── append_one_tree_to_another_tree.rs
├── evaluate_arithmetic_binary_tree.rs
├── mod.rs
├── sums_by_each_level.rs
└── tree.rs
vectors
├── mod.rs
└── two_sum.rs
#+end_src
