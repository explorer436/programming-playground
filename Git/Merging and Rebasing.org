* Merging

** Merge from a remote branch into a current branch

[[./images/GitNotes_936b0864_01.png]]

** Checkout a different branch and Merge from another remote branch into that branch

[[./images/GitNotes_936b0864_02.png]]

* Rebasing

** Move work from the feature branch onto the main branch

[[./images/GitNotes_936b0864_03.png]]

It will result in this:

[[./images/GitNotes_936b0864_04.png]]

* Resolving merge conflicts after a Git rebase

When you perform a ~git rebase~ operation, you're typically moving commits around. Because of this, you might get into a situation where a merge conflict is introduced. That means that two of your commits modified the same line in the same file, and Git doesn't know which change to apply.

After you reorder and manipulate commits using ~git rebase~, should a merge conflict occur, Git will tell you so with the following message printed to the terminal:

~error: could not apply fa39187... something to add to patch A~

When you have resolved this problem, run ~git rebase --continue~
If you prefer to skip this patch, run ~git rebase --skip~ instead.
To check out the original branch and stop rebasing, run ~git rebase --abort~

#+BEGIN_SRC
Could not apply fa39187f3c3dfd2ab5faa38ac01cf3de7ce2e841... Change fake file
#+END_SRC

Here, Git is telling you which commit is causing the conflict (fa39187). You're given three choices:

1. You can run ~git rebase --abort~ to completely undo the rebase. Git will return you to your branch's state as it was before git rebase was called.
2. You can run ~git rebase --skip~ to completely skip the commit. That means that none of the changes introduced by the problematic commit will be included. It is very rare that you would choose this option.
3. You can fix the conflict.

To fix the conflict, you can follow the standard procedures for resolving merge conflicts from the command line. When you're finished, you'll need to call ~git rebase --continue~ in order for Git to continue processing the rest of the rebase.


https://docs.github.com/en/github/getting-started-with-github/resolving-merge-conflicts-after-a-git-rebase

* Git Interactive Rebase

Git cherry-pick is great when you know which commits you want (and you know their corresponding hashes) -- it's hard to beat the simplicity that cherry-pick provides.

But what about the situation where you don't know what commits you want to pick? Thankfully, Git has you covered there as well! We can use interactive rebasing for this -- it's the best way to review a series of commits you're about to rebase.

All interactive rebase means Git is using the rebase command with the -i option.

If you include this option, git will open up a UI to show you which commits are about to be copied below the target of the rebase. It also shows their commit hashes and messages, which is great for getting a bearing on what's what.

When the interactive rebase dialog opens, you have the ability to do many things:

1. You can reorder commits simply by changing their order
1. You can choose to keep all commits or drop specific ones.
1. squashing (combining) commits
1. amending commit messages
1. editing the commits themselves

Here's a development situation that often happens: I'm trying to track down a bug but it is quite elusive. In order to aid in my detective work, I put in a few debug commands and a few print statements.

All of these debugging / print statements are in their own commits. Finally I track down the bug, fix it, and rejoice!

Only problem is that I now need to get my bugFix back into the main branch. If I simply fast-forwarded main, then main would get all my debug statements which is undesirable. There has to be another way...

We need to tell git to copy only one of the commits over. We can use the same commands:
1. ~git rebase -i~
1. ~git cherry-pick~
