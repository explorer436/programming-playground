* SQL topics                                                          :TOC_9:
- [[#database-model][database model]]
- [[#dataflow-diagram-dfd][dataflow diagram DFD]]
- [[#data-model][data model]]
  - [[#data-modeling][data modeling]]
- [[#sql][SQL]]
  - [[#named-sql-query][Named SQL query]]
  - [[#sqlexceptiontranslator][SQLExceptionTranslator]]
  - [[#sqlprovider][SQLProvider]]
  - [[#stored-procudures-sql-related][stored procudures (SQL related)]]
  - [[#aggregate-functions--sql-aggregate-functions][aggregate functions / SQL Aggregate Functions]]
  - [[#sql-top][SQL TOP]]
  - [[#sql-like][SQL LIKE]]
  - [[#sql-wildcards][SQL Wildcards]]
  - [[#sql-in-operator][SQL IN Operator]]
  - [[#sql-between-operator][SQL BETWEEN Operator]]
  - [[#sql-alias][SQL Alias]]
  - [[#sql-joins][SQL Joins]]
  - [[#sql-join][SQL JOIN]]
  - [[#sql-inner-join][SQL INNER JOIN]]
  - [[#sql-left-join--left-outer-join][SQL LEFT JOIN / LEFT OUTER JOIN]]
  - [[#sql-right-join--right-outer-join][SQL RIGHT JOIN / RIGHT OUTER JOIN]]
  - [[#sql-full-join][SQL FULL JOIN]]
  - [[#sql-union-operator][SQL UNION Operator]]
  - [[#sql-select-into-statement][SQL SELECT INTO Statement]]
  - [[#sql-create-database-statement][SQL CREATE DATABASE Statement]]
  - [[#sql-create-table-statement][SQL CREATE TABLE Statement]]
  - [[#sql-constraints][SQL Constraints]]
  - [[#sql-not-null-constraint][SQL NOT NULL Constraint]]
  - [[#sql-unique-constraint][SQL UNIQUE Constraint]]
  - [[#sql-primary-key-constraint][SQL PRIMARY KEY Constraint]]
  - [[#sql-foreign-key-constraint][SQL FOREIGN KEY Constraint]]
  - [[#sql-check-constraint][SQL CHECK Constraint]]
  - [[#sql-default-constraint][SQL DEFAULT Constraint]]
  - [[#sql-create-index-statement][SQL CREATE INDEX Statement]]
  - [[#indexes][Indexes]]
  - [[#the-drop-statement][The DROP Statement]]
  - [[#truncate-table-statement][TRUNCATE TABLE Statement]]
  - [[#sql-alter-table-statement][SQL ALTER TABLE Statement]]
  - [[#sql-auto-increment-field][SQL AUTO INCREMENT Field]]
  - [[#sql-views][SQL Views]]
  - [[#sql-date-functions][SQL Date Functions]]
  - [[#sql-null-values][SQL NULL Values]]
- [[#tables-vs-views][tables vs views]]
- [[#cursors][cursors]]
  - [[#implicit-cursors][Implicit cursors]]
  - [[#explicit-cursors][Explicit cursors]]

* database model
A database model is the theoretical foundation of a database and fundamentally determines in which manner data can be
stored, organized, and manipulated in a database system. It thereby defines the infrastructure offered by a particular
database system. The most popular example of a database model is the relational model.

* dataflow diagram DFD
DFD is a graphical representation of the flow of data through an information system, modeling its process aspects. it is a
preliminary step used to create an overview of the system which can be later elaborated.
* data model
A high-level data model in business or for any functional area is an abstract model that documents and organizes the
business data for communication between functional and technical people. It is used to show the data needed and
created by business processes.
refer: component model
refer: object model
** data modeling
Data modeling in software engineering is the process of creating a data model for an information system by applying
formal data modeling techniques. Data modeling is a process used to define and analyze data requirements needed to
support the business processes within the scope of corresponding information systems in organizations. Therefore, the
process of data modeling involves professional data modelers working closely with business stakeholders, as well as
potential users of the information system.

* SQL
Structured Query Language. The standardized relational database language for defining database objects and
manipulating data.
** Named SQL query
** SQLExceptionTranslator
SQLExceptionTranslator, is an interface to be implemented by classes that can translate between SQLExceptions
and Spring's own data-access-strategy-agnostic org.springframework.dao.DataAccessException.
** SQLProvider
• Has one method – getSql()
• Typically implemented byPreparedStatementCreator implementers.
• Useful for debugging
** stored procudures (SQL related)
A stored procedure is a subroutine available to applications that access a relational database system. A stored procedure
(sometimes called a proc, sproc, StoPro, StoredProc, or SP) is actually stored in the database data dictionary.
Typical uses for stored procedures include data validation (integrated into the database) or access control mechanisms.
Furthermore, stored procedures can consolidate and centralize logic that was originally implemented in applications.
Extensive or complex processing that requires execution of several SQL statements is moved into stored procedures, and
all applications call the procedures. One can use nested stored procedures, by executing one stored procedure from
within another.
Stored procedures are great for processing complex SQL logic, securing and controlling access to data, and returning a
rowset to a calling routine.
Stored procedures are similar to user-defined functions (UDFs). The major difference is that UDFs can be used like any
other expression within SQL statements, whereas stored procedures must be invoked using the CALL statement.
A user defined function (UDF) is a prepared code segment that can accept parameters, process some logic, and then
return some data. According to SQL Server Books Online, UDFs in SQL Server™ 2000 can accept anywhere from 0 to
1024 parameters, although I must confess I have never tried to pass 1024 parameters into a UDF. Another key
characteristic of UDFs is that they return a value. Depending on the type of UDF, the value can be used by the calling
routine to continue processing its data. Thus, if a UDF returns a single value (a scalar value), the calling routine can use
that value anywhere a standard variable or a literal value can be used. If a UDF returns a rowset, the calling routine can
loop through the rowset, join to it, or simply select columns from it.
Unlike views, stored procedures are compiled, making them ideal candidates to represent and process frequently run
SQL statements.
Views are limited to only certain columns and rows from the underlying SELECT statement that generated the view. Thus
a view is often used to represent a commonly used SELECT statement that may join several tables, employ a WHERE
clause, and expose specific columns. Views are often found in the FROM clause of a SQL statement joined to other tables
and views.
There are two main types of UDFs: scalar value-returning UDFs and table value-returning UDFs. Within table value UDFs
you'll find UDFs that return inline tables and multistatement tables.
refer: invoke stored procedures
refer: callable statement
** aggregate functions / SQL Aggregate Functions
an aggregate function is a function where the values of multiple rows are grouped together as input on certain criteria to
form a single value of more significant meaning or measurement such as a set, a bag or a list.
Common aggregate functions include:
■ Average()
■ Count()
■ Maximum()
■ Median()
■ Minimum()
■ Mode()
■ Sum()
SQL aggregate functions return a single value, calculated from values in a column
** SQL TOP
The TOP clause is used to specify the number of records to return.
The TOP clause can be very useful on large tables with thousands of records.
Returning a large number of records can impact on performance.
SELECT TOP number|percent column_name(s)FROM table_name;
SELECT TOP 2 * FROM Persons;
SELECT TOP 50 PERCENT * FROM Persons;
** SQL LIKE
The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
SELECT column_name(s)FROM table_name WHERE column_name LIKE pattern;
SELECT * FROM Persons WHERE City LIKE 's%';
** SQL Wildcards
SQL wildcards can substitute for one or more characters when searching for data in a database.
SQL wildcards must be used with the SQL LIKE operator.
With SQL, the following wildcards can be used: %, _, [charlist], [^charlist] or [!charlist]
SELECT * FROM Persons WHERE City LIKE '%nes%';
SELECT * FROM Persons WHERE FirstName LIKE '_la';
SELECT * FROM Persons WHERE LastName LIKE 'S_end_on';
** SQL IN Operator
The IN operator allows you to specify multiple values in a WHERE clause.
SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...);
SELECT * FROM Persons WHERE LastName IN ('Hansen','Pettersen');
** SQL BETWEEN Operator
The BETWEEN operator is used in a WHERE clause to select a range of data between two values.
The BETWEEN operator selects a range of data between two values. The values can be numbers, text, or dates.
SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2;
SELECT * FROM Persons WHERE LastName BETWEEN 'Hansen' AND 'Pettersen';
** SQL Alias
With SQL, an alias name can be given to a table or to a column.
You can give a table or a column another name by using an alias. This can be a good thing to do if you have very long or
complex table names or column names.
SQL Alias Syntax for Tables: SELECT column_name(s) FROM table_name AS alias_name;
SQL Alias Syntax for Columns: SELECT column_name AS alias_name FROM table_name;
SELECT po.OrderID, p.LastName, p.FirstName FROM Persons AS p,
Product_Orders AS po WHERE p.LastName='Hansen' AND p.FirstName='Ola';
** SQL Joins
SQL joins are used to query data from two or more tables, based on a relationship between certain columns in these
tables.
** SQL JOIN
The JOIN keyword is used in an SQL statement to query data from two or more tables, based on a relationship between
certain columns in these tables.
Tables in a database are often related to each other with keys.
A primary key is a column (or a combination of columns) with a unique value for each row. Each primary key value must
be unique within the table. The purpose is to bind data together, across tables, without repeating all of the data in every
table.
Different SQL JOINs
Before we continue with examples, we will list the types of JOIN you can use, and the differences between them.
• JOIN: Return rows when there is at least one match in both tables
• LEFT JOIN: Return all rows from the left table, even if there are no matches in the right table
• RIGHT JOIN: Return all rows from the right table, even if there are no matches in the left table
• FULL JOIN: Return rows when there is a match in one of the tables
** SQL INNER JOIN
The INNER JOIN keyword return rows when there is at least one match in both tables.
SELECT column_name(s) FROM table_name1 INNER JOIN table_name2
ON table_name1.column_name=table_name2.column_name.
INNER JOIN is the same as JOIN.
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons INNER JOIN Orders
ON Persons.P_Id=Orders.P_Id ORDER BY Persons.LastName;
The INNER JOIN keyword return rows when there is at least one match in both tables. If there are rows in "Persons" that
do not have matches in "Orders", those rows will NOT be listed.
** SQL LEFT JOIN / LEFT OUTER JOIN
The LEFT JOIN keyword returns all rows from the left table (table_name1), even if there are no matches in the right table
(table_name2).
SELECT column_name(s) FROM table_name1 LEFT JOIN table_name2
ON table_name1.column_name=table_name2.column_name;
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons
LEFT JOIN Orders ON Persons.P_Id=Orders.P_Id ORDER BY Persons.LastName;
The LEFT JOIN keyword returns all the rows from the left table (Persons), even if there are no matches in the right table
(Orders).
** SQL RIGHT JOIN / RIGHT OUTER JOIN
The RIGHT JOIN keyword returns all the rows from the right table (table_name2), even if there are no matches in the left
table (table_name1).
SELECT column_name(s) FROM table_name1 RIGHT JOIN table_name2 ON
table_name1.column_name=table_name2.column_name;
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons
RIGHT JOIN Orders ON Persons.P_Id=Orders.P_Id ORDER BY Persons.LastName;
The RIGHT JOIN keyword returns all the rows from the right table (Orders), even if there are no matches in the left table
(Persons).
** SQL FULL JOIN
The FULL JOIN keyword return rows when there is a match in one of the tables.
SELECT column_name(s) FROM table_name1 FULL JOIN table_name2 ON
table_name1.column_name=table_name2.column_name;
SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo FROM Persons
FULL JOIN Orders ON Persons.P_Id=Orders.P_Id ORDER BY Persons.LastName;
The FULL JOIN keyword returns all the rows from the left table (Persons), and all the rows from the right table (Orders). If
there are rows in "Persons" that do not have matches in "Orders", or if there are rows in "Orders" that do not have
matches in "Persons", those rows will be listed as well.
** SQL UNION Operator
The SQL UNION operator combines two or more SELECT statements.
The UNION operator is used to combine the result-set of two or more SELECT statements.
Notice that each SELECT statement within the UNION must have the same number of columns. The columns must also
have similar data types. Also, the columns in each SELECT statement must be in the same order.
SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2;
SELECT column_name(s) FROM table_name1
UNION ALL
SELECT column_name(s) FROM table_name2;
SELECT E_Name FROM Employees_Norway UNION SELECT E_Name FROM Employees_USA;
** SQL SELECT INTO Statement
The SQL SELECT INTO statement can be used to create backup copies of tables.
The SELECT INTO statement selects data from one table and inserts it into a different table.
The SELECT INTO statement is most often used to create backup copies of tables.
We can select all columns into the new table:
SELECT *
INTO new_table_name [IN externaldatabase]
FROM old_tablename;
Or we can select only the columns we want into the new table:
SELECT column_name(s)
INTO new_table_name [IN externaldatabase]
FROM old_tablename;
SELECT * INTO Persons_Backup FROM Persons;
** SQL CREATE DATABASE Statement
The CREATE DATABASE statement is used to create a database.
CREATE DATABASE database_name
Example:
We use the following CREATE DATABASE statement:
CREATE DATABASE my_db
Database tables can be added with the CREATE TABLE statement.
** SQL CREATE TABLE Statement
The CREATE TABLE statement is used to create a table in a database.
** SQL Constraints
Constraints are used to limit the type of data that can go into a table.
Constraints can be specified when a table is created (with the CREATE TABLE statement) or after the table is created
(with the ALTER TABLE statement).
We will focus on the following constraints:
• NOT NULL
• UNIQUE
• PRIMARY KEY
• FOREIGN KEY
• CHECK
• DEFAULT
• SQL NOT NULL Constraint
By default, a table column can hold NULL values.
** SQL NOT NULL Constraint
The NOT NULL constraint enforces a column to NOT accept NULL values.
The NOT NULL constraint enforces a field to always contain a value. This means that you cannot insert a new record, or
update a record without adding a value to this field.
The following SQL enforces the "P_Id" column and the "LastName" column to not accept NULL values:
CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255)
)
** SQL UNIQUE Constraint
The UNIQUE constraint uniquely identifies each record in a database table.
The UNIQUE and PRIMARY KEY constraints both provide a guarantee for uniqueness for a column or set of columns.
A PRIMARY KEY constraint automatically has a UNIQUE constraint defined on it.
Note that you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.
** SQL PRIMARY KEY Constraint
The PRIMARY KEY constraint uniquely identifies each record in a database table.
Primary keys must contain unique values.
A primary key column cannot contain NULL values.
Each table should have a primary key, and each table can have only ONE primary key.
** SQL FOREIGN KEY Constraint
A FOREIGN KEY in one table points to a PRIMARY KEY in another table.
** SQL CHECK Constraint
The CHECK constraint is used to limit the value range that can be placed in a column.
If you define a CHECK constraint on a single column it allows only certain values for this column.
If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in
the row.
SQL CHECK Constraint on CREATE TABLE
The following SQL creates a CHECK constraint on the "P_Id" column when the "Persons" table is created. The CHECK
constraint specifies that the column "P_Id" must only include integers greater than 0.
CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CHECK (P_Id>0)
)
** SQL DEFAULT Constraint
The DEFAULT constraint is used to insert a default value into a column.
The default value will be added to all new records, if no other value is specified.
SQL DEFAULT Constraint on CREATE TABLE
The following SQL creates a DEFAULT constraint on the "City" column when the "Persons" table is created:
My SQL / SQL Server / Oracle / MS Access:
CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT 'Sandnes'
)
** SQL CREATE INDEX Statement
The CREATE INDEX statement is used to create indexes in tables.
Indexes allow the database application to find data fast; without reading the whole table.
** Indexes
An index can be created in a table to find data more quickly and efficiently.
The users cannot see the indexes, they are just used to speed up searches/queries.
Note: Updating a table with indexes takes more time than updating a table without (because the indexes also need an
update). So you should only create indexes on columns (and tables) that will be frequently searched against.
SQL CREATE INDEX Syntax
Creates an index on a table. Duplicate values are allowed:
CREATE INDEX index_name
ON table_name (column_name)
SQL DROP INDEX, DROP TABLE, and DROP DATABASE
Indexes, tables, and databases can easily be deleted/removed with the DROP statement.
** The DROP Statement
The DROP INDEX statement is used to delete an index in a table.
DROP TABLE table_name
The DROP DATABASE Statement
** TRUNCATE TABLE Statement
What if we only want to delete the data inside the table, and not the table itself?
Then, use the TRUNCATE TABLE statement:
TRUNCATE TABLE table_name
** SQL ALTER TABLE Statement
The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.
ALTER TABLE table_name ADD column_name datatype;
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name ALTER COLUMN column_name datatype;
** SQL AUTO INCREMENT Field
Auto-increment allows a unique number to be generated when a new record is inserted into a table.
AUTO INCREMENT a Field
Very often we would like the value of the primary key field to be created automatically every time a new record is inserted.
We would like to create an auto-increment field in a table.
** SQL Views
A view is a virtual table.
This chapter shows how to create, update, and delete a view.
SQL CREATE VIEW Statement
In SQL, a view is a virtual table based on the result-set of an SQL statement.
A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the
database.
You can add SQL functions, WHERE, and JOIN statements to a view and present the data as if the data were coming
from one single table.
SQL CREATE VIEW Syntax
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
Note: A view always shows up-to-date data! The database engine recreates the data, using the view's SQL statement,
every time a user queries a view.
SQL CREATE VIEW Examples
If you have the Northwind database you can see that it has several views installed by default.
The view "Current Product List" lists all active products (products that are not discontinued) from the "Products" table. The
view is created with the following SQL:
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName FROM Products WHERE Discontinued=No;
SQL Updating a View
You can update a view by using the following syntax:
SQL CREATE OR REPLACE VIEW Syntax:
CREATE OR REPLACE VIEW view_name AS
SELECT column_name(s) FROM table_name WHERE condition;
Now we want to add the "Category" column to the "Current Product List" view. We will update the view with the following
SQL:
CREATE VIEW [Current Product List] AS
SELECT ProductID,ProductName,Category FROM Products WHERE Discontinued=No;
** SQL Date Functions
SQL Dates
 The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches
the format of the date column in the database.
As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is
involved, it gets complicated.
Before talking about the complications of querying for dates, we will look at the most important built-in functions for
working with dates.
MySQL Date Functions
The following table lists the most important built-in date functions in MySQL:
Function
Description
NOW()
Returns the current date and time
CURDATE()
Returns the current date
CURTIME()
Returns the current time
DATE()
Extracts the date part of a date or date/time expression
EXTRACT()
Returns a single part of a date/time
DATE_ADD()
Adds a specified time interval to a date
DATE_SUB()
Subtracts a specified time interval from a date
DATEDIFF()
Returns the number of days between two dates
DATE_FORMAT()
Displays date/time data in different formats
SQL Server Date Functions
The following table lists the most important built-in date functions in SQL Server:
GETDATE():
Returns the current date and time
DATEPART()
Returns a single part of a date/time
DATEADD()
Adds or subtracts a specified time interval from a date
DATEDIFF()
Returns the time between two dates
CONVERT()
Displays date/time data in different formats
** SQL NULL Values
NULL values represent missing unknown data.
By default, a table column can hold NULL values.
This chapter will explain the IS NULL and IS NOT NULL operators.
SQL NULL Values
If a column in a table is optional, we can insert a new record or update an existing record without adding a value to this
column. This means that the field will be saved with a NULL value.
NULL values are treated differently from other values.
NULL is used as a placeholder for unknown or inapplicable values.
SQL NULL Functions
SQL ISNULL(), NVL(), IFNULL() and COALESCE() Functions
SQL Server / MS Access
SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))
FROM Products
Oracle
Oracle does not have an ISNULL() function. However, we can use the NVL() function to achieve the same result:
SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))
FROM Products

* tables vs views
Table - Storage Unit Contain Rows and Columns. RDBMS is composed of tables that contain related data. table is stored
in the database. Tables have physical existence.
View - Logical Subset of Tables. View is an Database Object we can use DML it affects the base table and view.we can
create a object for that table. View is a virtual table which do not have any physical existence.
1. This is one type of relation which is not a part of the physical database.
2. It has no direct or physical relation with the database.
3. Views can be used to provide security mechanism.
4. Modification through a view (e.g. insert, update, delete) generally not permitted
A VIEW is only a mirror image of table which is used at places where large access to a table is required.
Views cannot be updated,deleted and modified but we could select data from views easily.
Base Relation:
1. A base relation is a relation that is not a derived relation.
2. While it can manipulate the conceptual or physical relations stored in the data.
3. It does not provide security.
4. Modification may be done with a base relation.
We can assign the view, a name & relate it the query expression as “Create View as”
Let EMPLOYEE be the relation. We create the table EMPLOYEE as follows:-
Create table EMPLOYEE
(Emp_No integer of null,
Name char (20),
Skill chars (20),
Sal_Rate decimal (10, 2),
DOB date,
Address char (100),)
For a very personal or confidential matter, every user is not permitted to see the Sal_Rate of an EMPLOYEE. For such
users, DBA can create a view, for example, EMP_VIEW defined as:-
Create view EMP_VIEW as
(Select Emp_No, Name, Skill, DOB, Address
         From EMPLOYEE)
View :
1. Views are created from one or more than one table by joins, with selected columns.
2. Views acts as a layer between user and table.
3. Views are created to hide some columns from the user for security reasons, and to hide information exist in the column.
4. Views reduces the effort for writing queries to access specific columns every time.
5. Reports can be created on views.
6. View doesn't contain any data.
For data hiding to users from the data table we use views. Views stores only a particular query.Whenever we call that
view it executes that query only. It does not store any data.We can also get some attributes of a table as view.
View is different perspective to see output from a table.
  View data can not take part in Manipulation.
 We can update or delete view.
View is nothing but a query file which stores the Sql Query, which is similar to the query file in Foxpro. When executed the
query returns the rows from the tables specified in the query which satisfies the conditions (to a dynamic virtual table
which has the column names specified in the query). That is why each an every time the view displays different result set
depending on the data in the table.
View is a subset of data derived from table.
Update of data in table we can see in in view but update in view can not see in table.
Views are associated with tables.
we can create a view with base table and can able to execute DML(insert , delete,update and select ) statements if we
update view then the base table get updated....
Code
1. CREATE TABLE a( id int,name CHAR(20));
2. SELECT * FROM a;
3. INSERT INTO a VALUES(50,'e');
4. CREATE VIEW a1 AS SELECT * FROM a
5. SELECT * FROM a1;
6. INSERT INTO a1 VALUES(200,'ase');
7. DELETE FROM a1 WHERE id=100;
8. UPDATE a1
9. SET name='xyz'
10. WHERE id=10;

* cursors
A cursor is a temporary work area created in the system memory when a SQL statement is executed. A cursor contains
information on a select statement and the rows of data accessed by it. This temporary work area is used to store the data
retrieved from the database, and manipulate this data. A cursor can hold more than one row, but can process only one
row at a time. The set of rows the cursor holds is called the active set.
There are two types of cursors in PL/SQL:
** Implicit cursors
These are created by default when DML statements like, INSERT, UPDATE, and DELETE statements are executed. They
are also created when a SELECT statement that returns just one row is executed.
** Explicit cursors
They must be created when you are executing a SELECT statement that returns more than one row. Even though the
cursor stores multiple records, only one record can be processed at a time, which is called as current row. When you fetch
a row the current row position moves to next row.
Both implicit and explicit cursors have the same functionality, but they differ in the way they are accessed.
